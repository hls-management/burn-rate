{"version":3,"file":"models-D6RH2t8d.js","sources":["../../../src/models/Economy.ts","../../../src/models/Fleet.ts","../../../src/models/AI.ts","../../../src/models/Intelligence.ts","../../../src/models/validation.ts"],"sourcesContent":["export type StructureType = 'reactor' | 'mine';\nexport type BuildableType = 'frigate' | 'cruiser' | 'battleship' | 'reactor' | 'mine';\n\nexport interface Resources {\n  metal: number;\n  energy: number;\n  metalIncome: number;\n  energyIncome: number;\n}\n\nexport interface BuildOrder {\n  unitType: BuildableType;\n  quantity: number;\n  turnsRemaining: number;\n  resourceDrainPerTurn: {\n    metal: number;\n    energy: number;\n  };\n}\n\nexport interface Economy {\n  reactors: number;\n  mines: number;\n  constructionQueue: BuildOrder[];\n}\n\nexport interface StructureStats {\n  buildCost: {\n    metal: number;\n    energy: number;\n  };\n  buildTime: number;\n  incomeBonus: {\n    metal: number;\n    energy: number;\n  };\n}\n\nexport const STRUCTURE_STATS: Record<StructureType, StructureStats> = {\n  reactor: {\n    buildCost: { metal: 900, energy: 1200 },\n    buildTime: 1,\n    incomeBonus: { metal: 0, energy: 500 }\n  },\n  mine: {\n    buildCost: { metal: 1500, energy: 600 },\n    buildTime: 1,\n    incomeBonus: { metal: 500, energy: 0 }\n  }\n};\n\nexport const BASE_INCOME = {\n  metal: 10000,\n  energy: 10000\n};\n\n/**\n * Economic structure management and build order functions\n */\n\nexport interface EconomyValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\n/**\n * Validates a build order for correctness\n */\nexport function validateBuildOrder(buildOrder: BuildOrder): EconomyValidationResult {\n  const errors: string[] = [];\n\n  if (buildOrder.quantity <= 0) {\n    errors.push('Build order quantity must be positive');\n  }\n\n  if (buildOrder.turnsRemaining < 0) {\n    errors.push('Turns remaining cannot be negative');\n  }\n\n  if (buildOrder.resourceDrainPerTurn.metal < 0) {\n    errors.push('Metal drain per turn cannot be negative');\n  }\n\n  if (buildOrder.resourceDrainPerTurn.energy < 0) {\n    errors.push('Energy drain per turn cannot be negative');\n  }\n\n  const validTypes: BuildableType[] = ['frigate', 'cruiser', 'battleship', 'reactor', 'mine'];\n  if (!validTypes.includes(buildOrder.unitType)) {\n    errors.push(`Invalid unit type: ${buildOrder.unitType}`);\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validates an entire construction queue\n */\nexport function validateConstructionQueue(queue: BuildOrder[]): EconomyValidationResult {\n  const errors: string[] = [];\n\n  for (let i = 0; i < queue.length; i++) {\n    const validation = validateBuildOrder(queue[i]);\n    if (!validation.isValid) {\n      errors.push(...validation.errors.map(err => `Build order ${i + 1}: ${err}`));\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Calculates the exponential cost for building additional structures\n * Formula: Cost = Base Cost × (1 + 0.5 × Structure Count)^1.2\n */\nexport function calculateStructureCost(structureType: StructureType, currentCount: number): { metal: number; energy: number } {\n  const baseCost = STRUCTURE_STATS[structureType].buildCost;\n  const multiplier = Math.pow(1 + 0.5 * currentCount, 1.2);\n\n  return {\n    metal: Math.ceil(baseCost.metal * multiplier),\n    energy: Math.ceil(baseCost.energy * multiplier)\n  };\n}\n\n/**\n * Calculates the total income from economic structures\n */\nexport function calculateStructureIncome(reactors: number, mines: number): { metal: number; energy: number } {\n  return {\n    metal: BASE_INCOME.metal + (mines * STRUCTURE_STATS.mine.incomeBonus.metal),\n    energy: BASE_INCOME.energy + (reactors * STRUCTURE_STATS.reactor.incomeBonus.energy)\n  };\n}\n\n/**\n * Calculates the total resource drain from all active build orders\n */\nexport function calculateConstructionDrain(constructionQueue: BuildOrder[]): { metal: number; energy: number } {\n  let totalMetalDrain = 0;\n  let totalEnergyDrain = 0;\n\n  for (const buildOrder of constructionQueue) {\n    totalMetalDrain += buildOrder.resourceDrainPerTurn.metal;\n    totalEnergyDrain += buildOrder.resourceDrainPerTurn.energy;\n  }\n\n  return {\n    metal: totalMetalDrain,\n    energy: totalEnergyDrain\n  };\n}\n\n/**\n * Calculates net income after construction drain\n */\nexport function calculateNetIncome(\n  structureIncome: { metal: number; energy: number },\n  constructionDrain: { metal: number; energy: number }\n): { metal: number; energy: number } {\n  return {\n    metal: structureIncome.metal - constructionDrain.metal,\n    energy: structureIncome.energy - constructionDrain.energy\n  };\n}\n\n/**\n * Creates a build order for a structure\n */\nexport function createStructureBuildOrder(\n  structureType: StructureType,\n  quantity: number,\n  currentCount: number\n): BuildOrder {\n  const cost = calculateStructureCost(structureType, currentCount);\n  const buildTime = STRUCTURE_STATS[structureType].buildTime;\n\n  return {\n    unitType: structureType,\n    quantity,\n    turnsRemaining: buildTime,\n    resourceDrainPerTurn: {\n      metal: cost.metal * quantity,\n      energy: cost.energy * quantity\n    }\n  };\n}\n\n/**\n * Creates a build order for units (from Fleet.ts unit stats)\n */\nexport function createUnitBuildOrder(\n  unitType: 'frigate' | 'cruiser' | 'battleship',\n  quantity: number,\n  unitStats: { buildTime: number; buildCost: { metal: number; energy: number } }\n): BuildOrder {\n  return {\n    unitType,\n    quantity,\n    turnsRemaining: unitStats.buildTime,\n    resourceDrainPerTurn: {\n      metal: unitStats.buildCost.metal * quantity,\n      energy: unitStats.buildCost.energy * quantity\n    }\n  };\n}\n\n/**\n * Processes construction queue for one turn, completing finished orders\n */\nexport function processConstructionQueue(\n  queue: BuildOrder[]\n): { completedOrders: BuildOrder[]; remainingQueue: BuildOrder[] } {\n  const completedOrders: BuildOrder[] = [];\n  const remainingQueue: BuildOrder[] = [];\n\n  for (const order of queue) {\n    const updatedOrder = { ...order, turnsRemaining: order.turnsRemaining - 1 };\n    \n    if (updatedOrder.turnsRemaining <= 0) {\n      completedOrders.push(updatedOrder);\n    } else {\n      remainingQueue.push(updatedOrder);\n    }\n  }\n\n  return { completedOrders, remainingQueue };\n}\n\n/**\n * Checks if resources are sufficient to start a build order\n */\nexport function canAffordBuildOrder(\n  resources: Resources,\n  buildOrder: BuildOrder\n): boolean {\n  const totalMetalCost = buildOrder.resourceDrainPerTurn.metal * buildOrder.turnsRemaining;\n  const totalEnergyCost = buildOrder.resourceDrainPerTurn.energy * buildOrder.turnsRemaining;\n\n  return resources.metal >= totalMetalCost && resources.energy >= totalEnergyCost;\n}\n\n/**\n * Checks if income can sustain a build order's drain\n */\nexport function canSustainBuildOrder(\n  netIncome: { metal: number; energy: number },\n  buildOrder: BuildOrder\n): boolean {\n  return netIncome.metal >= buildOrder.resourceDrainPerTurn.metal &&\n         netIncome.energy >= buildOrder.resourceDrainPerTurn.energy;\n}\n\n/**\n * Calculates payback time for a structure investment\n */\nexport function calculateStructurePaybackTime(structureType: StructureType, currentCount: number): number {\n  const cost = calculateStructureCost(structureType, currentCount);\n  const incomeBonus = STRUCTURE_STATS[structureType].incomeBonus;\n\n  // Calculate turns needed to pay back the investment for the resource the structure produces\n  if (structureType === 'reactor') {\n    // Reactors produce energy, so calculate payback based on energy cost and energy income\n    return cost.energy / incomeBonus.energy;\n  } else if (structureType === 'mine') {\n    // Mines produce metal, so calculate payback based on metal cost and metal income\n    return cost.metal / incomeBonus.metal;\n  }\n\n  return Infinity;\n}\n\n/**\n * Determines if building a structure is economically viable\n */\nexport function isStructureViable(\n  structureType: StructureType,\n  currentCount: number,\n  maxPaybackTurns: number = 10\n): boolean {\n  const paybackTime = calculateStructurePaybackTime(structureType, currentCount);\n  return paybackTime <= maxPaybackTurns;\n}\n\n/**\n * Creates an empty economy state\n */\nexport function createEmptyEconomy(): Economy {\n  return {\n    reactors: 0,\n    mines: 0,\n    constructionQueue: []\n  };\n}\n\n/**\n * Calculates total economic structures\n */\nexport function getTotalStructures(economy: Economy): number {\n  return economy.reactors + economy.mines;\n}","import { FleetComposition } from './GameState.js';\n\nexport type UnitType = 'frigate' | 'cruiser' | 'battleship';\nexport type MissionType = 'outbound' | 'combat' | 'returning';\n\nexport interface FleetMovement {\n  composition: FleetComposition;\n  target: string;\n  arrivalTurn: number;\n  returnTurn: number;\n  missionType: MissionType;\n}\n\nexport interface Fleet {\n  homeSystem: FleetComposition;\n  inTransit: {\n    outbound: FleetMovement[];\n  };\n}\n\nexport interface UnitStats {\n  buildTime: number;\n  buildCost: {\n    metal: number;\n    energy: number;\n  };\n  upkeepCost: {\n    metal: number;\n    energy: number;\n  };\n  effectiveness: {\n    vsFrigate: number;\n    vsCruiser: number;\n    vsBattleship: number;\n  };\n}\n\nexport const UNIT_STATS: Record<UnitType, UnitStats> = {\n  frigate: {\n    buildTime: 1,\n    buildCost: { metal: 4, energy: 2 },\n    upkeepCost: { metal: 2, energy: 1 },\n    effectiveness: { vsFrigate: 1.0, vsCruiser: 1.5, vsBattleship: 0.7 }\n  },\n  cruiser: {\n    buildTime: 2,\n    buildCost: { metal: 10, energy: 6 },\n    upkeepCost: { metal: 5, energy: 3 },\n    effectiveness: { vsFrigate: 0.7, vsCruiser: 1.0, vsBattleship: 1.5 }\n  },\n  battleship: {\n    buildTime: 4,\n    buildCost: { metal: 20, energy: 12 },\n    upkeepCost: { metal: 10, energy: 6 },\n    effectiveness: { vsFrigate: 1.5, vsCruiser: 0.7, vsBattleship: 1.0 }\n  }\n};\n\n/**\n * Fleet composition and management functions\n */\n\nexport interface FleetValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\n/**\n * Validates a fleet composition for basic integrity\n */\nexport function validateFleetComposition(composition: FleetComposition): FleetValidationResult {\n  const errors: string[] = [];\n\n  if (composition.frigates < 0) {\n    errors.push('Frigate count cannot be negative');\n  }\n  if (composition.cruisers < 0) {\n    errors.push('Cruiser count cannot be negative');\n  }\n  if (composition.battleships < 0) {\n    errors.push('Battleship count cannot be negative');\n  }\n\n  // Check for reasonable upper bounds (prevent integer overflow scenarios)\n  const maxUnits = 1000000;\n  if (composition.frigates > maxUnits || composition.cruisers > maxUnits || composition.battleships > maxUnits) {\n    errors.push('Unit counts exceed reasonable maximum');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validates a fleet movement for timing and composition integrity\n */\nexport function validateFleetMovement(movement: FleetMovement, currentTurn: number): FleetValidationResult {\n  const errors: string[] = [];\n\n  // Validate composition\n  const compositionValidation = validateFleetComposition(movement.composition);\n  if (!compositionValidation.isValid) {\n    errors.push(...compositionValidation.errors);\n  }\n\n  // Validate timing\n  if (movement.arrivalTurn <= currentTurn) {\n    errors.push('Arrival turn must be in the future');\n  }\n\n  if (movement.returnTurn <= movement.arrivalTurn) {\n    errors.push('Return turn must be after arrival turn');\n  }\n\n  // Validate mission type\n  const validMissionTypes: MissionType[] = ['outbound', 'combat', 'returning'];\n  if (!validMissionTypes.includes(movement.missionType)) {\n    errors.push(`Invalid mission type: ${movement.missionType}`);\n  }\n\n  // Validate target\n  if (!movement.target || movement.target.trim().length === 0) {\n    errors.push('Movement target cannot be empty');\n  }\n\n  // Validate fleet is not empty\n  if (getTotalFleetSize(movement.composition) === 0) {\n    errors.push('Cannot send empty fleet');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Calculates the total number of ships in a fleet composition\n */\nexport function getTotalFleetSize(composition: FleetComposition): number {\n  return composition.frigates + composition.cruisers + composition.battleships;\n}\n\n/**\n * Calculates the total upkeep cost for a fleet composition\n */\nexport function calculateFleetUpkeep(composition: FleetComposition): { metal: number; energy: number } {\n  const metalUpkeep = \n    composition.frigates * UNIT_STATS.frigate.upkeepCost.metal +\n    composition.cruisers * UNIT_STATS.cruiser.upkeepCost.metal +\n    composition.battleships * UNIT_STATS.battleship.upkeepCost.metal;\n\n  const energyUpkeep = \n    composition.frigates * UNIT_STATS.frigate.upkeepCost.energy +\n    composition.cruisers * UNIT_STATS.cruiser.upkeepCost.energy +\n    composition.battleships * UNIT_STATS.battleship.upkeepCost.energy;\n\n  return { metal: metalUpkeep, energy: energyUpkeep };\n}\n\n/**\n * Calculates the total construction cost for a fleet composition\n */\nexport function calculateFleetBuildCost(composition: FleetComposition): { metal: number; energy: number } {\n  const metalCost = \n    composition.frigates * UNIT_STATS.frigate.buildCost.metal +\n    composition.cruisers * UNIT_STATS.cruiser.buildCost.metal +\n    composition.battleships * UNIT_STATS.battleship.buildCost.metal;\n\n  const energyCost = \n    composition.frigates * UNIT_STATS.frigate.buildCost.energy +\n    composition.cruisers * UNIT_STATS.cruiser.buildCost.energy +\n    composition.battleships * UNIT_STATS.battleship.buildCost.energy;\n\n  return { metal: metalCost, energy: energyCost };\n}\n\n/**\n * Adds two fleet compositions together\n */\nexport function addFleetCompositions(fleet1: FleetComposition, fleet2: FleetComposition): FleetComposition {\n  return {\n    frigates: fleet1.frigates + fleet2.frigates,\n    cruisers: fleet1.cruisers + fleet2.cruisers,\n    battleships: fleet1.battleships + fleet2.battleships\n  };\n}\n\n/**\n * Subtracts fleet2 from fleet1, ensuring no negative values\n */\nexport function subtractFleetCompositions(fleet1: FleetComposition, fleet2: FleetComposition): FleetComposition {\n  return {\n    frigates: Math.max(0, fleet1.frigates - fleet2.frigates),\n    cruisers: Math.max(0, fleet1.cruisers - fleet2.cruisers),\n    battleships: Math.max(0, fleet1.battleships - fleet2.battleships)\n  };\n}\n\n/**\n * Checks if fleet1 has at least as many ships as fleet2\n */\nexport function canAffordFleetComposition(available: FleetComposition, required: FleetComposition): boolean {\n  return available.frigates >= required.frigates &&\n         available.cruisers >= required.cruisers &&\n         available.battleships >= required.battleships;\n}\n\n/**\n * Creates an empty fleet composition\n */\nexport function createEmptyFleet(): FleetComposition {\n  return {\n    frigates: 0,\n    cruisers: 0,\n    battleships: 0\n  };\n}\n\n/**\n * Checks if a fleet composition is empty (no ships)\n */\nexport function isFleetEmpty(composition: FleetComposition): boolean {\n  return getTotalFleetSize(composition) === 0;\n}\n\n/**\n * Generates a random factor for combat calculations (0.8-1.2x per unit type)\n */\nexport function generateRandomFactor(): number {\n  return 0.8 + Math.random() * 0.4;\n}\n\n/**\n * Calculates combat strength for a specific unit type against enemy composition\n */\nexport function calculateUnitTypeStrength(\n  unitCount: number,\n  unitType: UnitType,\n  enemyComposition: FleetComposition,\n  randomFactor: number = generateRandomFactor()\n): number {\n  if (unitCount === 0) return 0;\n\n  const stats = UNIT_STATS[unitType];\n  \n  // Calculate effectiveness against each enemy unit type\n  const vsfrigates = unitCount * stats.effectiveness.vsFrigate * enemyComposition.frigates;\n  const vsCruisers = unitCount * stats.effectiveness.vsCruiser * enemyComposition.cruisers;\n  const vsBattleships = unitCount * stats.effectiveness.vsBattleship * enemyComposition.battleships;\n  \n  const baseStrength = vsfrigates + vsCruisers + vsBattleships;\n  \n  // Apply random factor per unit type\n  return baseStrength * randomFactor;\n}\n\n/**\n * Calculates total fleet combat strength with individual random factors per unit type\n */\nexport function calculateFleetStrength(\n  attacker: FleetComposition, \n  defender: FleetComposition,\n  randomFactors?: { frigate: number; cruiser: number; battleship: number }\n): number {\n  // Generate random factors if not provided (for testing determinism)\n  const factors = randomFactors || {\n    frigate: generateRandomFactor(),\n    cruiser: generateRandomFactor(),\n    battleship: generateRandomFactor()\n  };\n\n  const frigateStrength = calculateUnitTypeStrength(\n    attacker.frigates, \n    'frigate', \n    defender, \n    factors.frigate\n  );\n  \n  const cruiserStrength = calculateUnitTypeStrength(\n    attacker.cruisers, \n    'cruiser', \n    defender, \n    factors.cruiser\n  );\n  \n  const battleshipStrength = calculateUnitTypeStrength(\n    attacker.battleships, \n    'battleship', \n    defender, \n    factors.battleship\n  );\n\n  return frigateStrength + cruiserStrength + battleshipStrength;\n}\n\n/**\n * Creates a fleet movement for attacking a target with 3-turn cycle\n */\nexport function createFleetMovement(\n  composition: FleetComposition,\n  target: string,\n  currentTurn: number\n): FleetMovement {\n  return {\n    composition,\n    target,\n    arrivalTurn: currentTurn + 1, // Takes 1 turn to reach target\n    returnTurn: currentTurn + 3,   // Takes 1 turn for combat + 1 turn to return\n    missionType: 'outbound'\n  };\n}\n\n/**\n * Checks if a fleet is currently in transit (invisible to scans)\n */\nexport function isFleetInTransit(movement: FleetMovement, currentTurn: number): boolean {\n  return currentTurn >= movement.arrivalTurn - 1 && currentTurn < movement.returnTurn;\n}\n\n/**\n * Checks if a fleet can be recalled (only before departure)\n */\nexport function canRecallFleet(movement: FleetMovement, currentTurn: number): boolean {\n  return currentTurn < movement.arrivalTurn - 1;\n}\n\n/**\n * Updates fleet movement mission type based on current turn\n */\nexport function updateFleetMissionType(movement: FleetMovement, currentTurn: number): FleetMovement {\n  let missionType: MissionType;\n  \n  if (currentTurn < movement.arrivalTurn) {\n    missionType = 'outbound';\n  } else if (currentTurn === movement.arrivalTurn) {\n    missionType = 'combat';\n  } else {\n    missionType = 'returning';\n  }\n  \n  return {\n    ...movement,\n    missionType\n  };\n}\n\n/**\n * Processes fleet movements for a turn, returning movements that need combat resolution\n */\nexport function processFleetMovements(\n  movements: FleetMovement[],\n  currentTurn: number\n): {\n  updated: FleetMovement[];\n  combatMovements: FleetMovement[];\n  returning: FleetMovement[];\n} {\n  const updated: FleetMovement[] = [];\n  const combatMovements: FleetMovement[] = [];\n  const returning: FleetMovement[] = [];\n  \n  for (const movement of movements) {\n    const updatedMovement = updateFleetMissionType(movement, currentTurn);\n    \n    if (updatedMovement.missionType === 'combat') {\n      combatMovements.push(updatedMovement);\n    } else if (updatedMovement.missionType === 'returning') {\n      returning.push(updatedMovement);\n    } else {\n      updated.push(updatedMovement);\n    }\n  }\n  \n  return { updated, combatMovements, returning };\n}\n\n/**\n * Checks if a player's home system is vulnerable to counter-attack\n * (has fleets in transit and reduced home defense)\n */\nexport function isHomeSystemVulnerable(\n  homeFleet: FleetComposition,\n  outboundMovements: FleetMovement[],\n  currentTurn: number\n): boolean {\n  // Check if any fleets are in transit\n  const fleetsInTransit = outboundMovements.some(movement => \n    isFleetInTransit(movement, currentTurn)\n  );\n  \n  // Home system is vulnerable if fleets are in transit\n  return fleetsInTransit;\n}\n\n/**\n * Calculates the counter-attack window for a fleet movement\n */\nexport function getCounterAttackWindow(movement: FleetMovement): {\n  startTurn: number;\n  endTurn: number;\n  duration: number;\n} {\n  const startTurn = movement.arrivalTurn - 1; // Fleet departs, home vulnerable\n  const endTurn = movement.returnTurn - 1;    // Fleet returns next turn\n  const duration = endTurn - startTurn + 1;\n  \n  return { startTurn, endTurn, duration };\n}\n\n/**\n * Gets all fleets that are currently visible to scans (not in transit)\n */\nexport function getVisibleFleets(\n  homeFleet: FleetComposition,\n  outboundMovements: FleetMovement[],\n  currentTurn: number\n): FleetComposition {\n  // Only home fleet is visible, in-transit fleets are invisible\n  const fleetsInTransit = outboundMovements.filter(movement => \n    isFleetInTransit(movement, currentTurn)\n  );\n  \n  // If no fleets in transit, return full home fleet\n  if (fleetsInTransit.length === 0) {\n    return homeFleet;\n  }\n  \n  // Return only the home fleet (in-transit fleets are invisible)\n  return homeFleet;\n}\n\n/**\n * Creates a returning fleet movement after combat\n */\nexport function createReturningFleet(\n  survivors: FleetComposition,\n  originalMovement: FleetMovement,\n  currentTurn: number\n): FleetMovement | null {\n  // If no survivors, no fleet returns\n  if (getTotalFleetSize(survivors) === 0) {\n    return null;\n  }\n  \n  return {\n    composition: survivors,\n    target: 'home', // Returning home\n    arrivalTurn: currentTurn + 1, // Takes 1 turn to return\n    returnTurn: currentTurn + 1,  // Arrives home immediately\n    missionType: 'returning'\n  };\n}\n/**\n\n * Combat Resolution Engine\n */\n\nexport interface CombatResult {\n  outcome: 'decisive_attacker' | 'decisive_defender' | 'close_battle';\n  attackerSurvivors: FleetComposition;\n  defenderSurvivors: FleetComposition;\n  attackerCasualties: FleetComposition;\n  defenderCasualties: FleetComposition;\n  strengthRatio: number;\n}\n\n/**\n * Determines battle outcome based on strength ratio\n */\nexport function determineBattleOutcome(attackerStrength: number, defenderStrength: number): 'decisive_attacker' | 'decisive_defender' | 'close_battle' {\n  // If attacker has no strength, defender wins decisively\n  if (attackerStrength === 0) {\n    return 'decisive_defender';\n  }\n  \n  // If defender has no strength, attacker wins decisively\n  if (defenderStrength === 0) {\n    return 'decisive_attacker';\n  }\n  \n  const ratio = attackerStrength / defenderStrength;\n  \n  // Decisive victory if one side has 2x or more strength\n  if (ratio >= 2.0) {\n    return 'decisive_attacker';\n  } else if (ratio <= 0.5) {\n    return 'decisive_defender';\n  } else {\n    return 'close_battle';\n  }\n}\n\n/**\n * Calculates casualties based on battle outcome\n */\nexport function calculateCasualties(\n  fleet: FleetComposition,\n  outcome: 'decisive_attacker' | 'decisive_defender' | 'close_battle',\n  isWinner: boolean\n): { survivors: FleetComposition; casualties: FleetComposition } {\n  let casualtyRate: number;\n  \n  if (outcome === 'close_battle') {\n    // Close battles: 40-60% casualties for both sides\n    casualtyRate = 0.4 + Math.random() * 0.2;\n  } else {\n    if (isWinner) {\n      // Decisive winner: 10-30% casualties\n      casualtyRate = 0.1 + Math.random() * 0.2;\n    } else {\n      // Decisive loser: 70-90% casualties\n      casualtyRate = 0.7 + Math.random() * 0.2;\n    }\n  }\n  \n  const frigatesCasualties = Math.floor(fleet.frigates * casualtyRate);\n  const cruisersCasualties = Math.floor(fleet.cruisers * casualtyRate);\n  const battleshipsCasualties = Math.floor(fleet.battleships * casualtyRate);\n  \n  const casualties: FleetComposition = {\n    frigates: frigatesCasualties,\n    cruisers: cruisersCasualties,\n    battleships: battleshipsCasualties\n  };\n  \n  const survivors: FleetComposition = {\n    frigates: fleet.frigates - frigatesCasualties,\n    cruisers: fleet.cruisers - cruisersCasualties,\n    battleships: fleet.battleships - battleshipsCasualties\n  };\n  \n  return { survivors, casualties };\n}\n\n/**\n * Resolves combat between two fleets\n */\nexport function resolveCombat(\n  attacker: FleetComposition,\n  defender: FleetComposition,\n  randomFactors?: { \n    attackerFactors: { frigate: number; cruiser: number; battleship: number };\n    defenderFactors: { frigate: number; cruiser: number; battleship: number };\n  }\n): CombatResult {\n  // Calculate combat strengths\n  const attackerStrength = calculateFleetStrength(\n    attacker, \n    defender, \n    randomFactors?.attackerFactors\n  );\n  \n  const defenderStrength = calculateFleetStrength(\n    defender, \n    attacker, \n    randomFactors?.defenderFactors\n  );\n  \n  // Determine battle outcome\n  const outcome = determineBattleOutcome(attackerStrength, defenderStrength);\n  \n  // Calculate casualties\n  const attackerResult = calculateCasualties(\n    attacker, \n    outcome, \n    outcome === 'decisive_attacker'\n  );\n  \n  const defenderResult = calculateCasualties(\n    defender, \n    outcome, \n    outcome === 'decisive_defender'\n  );\n  \n  const strengthRatio = defenderStrength > 0 ? attackerStrength / defenderStrength : Infinity;\n  \n  return {\n    outcome,\n    attackerSurvivors: attackerResult.survivors,\n    defenderSurvivors: defenderResult.survivors,\n    attackerCasualties: attackerResult.casualties,\n    defenderCasualties: defenderResult.casualties,\n    strengthRatio\n  };\n}\n\n/**\n * Checks if a player has been eliminated (no fleets remaining)\n */\nexport function checkFleetElimination(\n  homeFleet: FleetComposition,\n  outboundMovements: FleetMovement[]\n): boolean {\n  // Check if home fleet is empty\n  if (getTotalFleetSize(homeFleet) > 0) {\n    return false;\n  }\n  \n  // Check if any fleets are in transit\n  for (const movement of outboundMovements) {\n    if (getTotalFleetSize(movement.composition) > 0) {\n      return false;\n    }\n  }\n  \n  // No fleets anywhere - player is eliminated\n  return true;\n}\n\n/**\n * Processes combat for a fleet movement and returns updated game state\n */\nexport function processCombatMovement(\n  movement: FleetMovement,\n  defenderHomeFleet: FleetComposition,\n  currentTurn: number\n): {\n  combatResult: CombatResult;\n  returningFleet: FleetMovement | null;\n  updatedDefenderFleet: FleetComposition;\n} {\n  // Resolve combat\n  const combatResult = resolveCombat(movement.composition, defenderHomeFleet);\n  \n  // Create returning fleet from survivors\n  const returningFleet = createReturningFleet(\n    combatResult.attackerSurvivors,\n    movement,\n    currentTurn\n  );\n  \n  // Update defender's home fleet with survivors\n  const updatedDefenderFleet = combatResult.defenderSurvivors;\n  \n  return {\n    combatResult,\n    returningFleet,\n    updatedDefenderFleet\n  };\n}\n\n/**\n * Checks victory conditions for the game\n */\nexport function checkVictoryConditions(\n  playerHomeFleet: FleetComposition,\n  playerOutboundMovements: FleetMovement[],\n  aiHomeFleet: FleetComposition,\n  aiOutboundMovements: FleetMovement[]\n): 'player_victory' | 'ai_victory' | 'ongoing' {\n  const playerEliminated = checkFleetElimination(playerHomeFleet, playerOutboundMovements);\n  const aiEliminated = checkFleetElimination(aiHomeFleet, aiOutboundMovements);\n  \n  if (playerEliminated && aiEliminated) {\n    // Mutual elimination - could be a draw, but for simplicity, AI wins\n    return 'ai_victory';\n  } else if (playerEliminated) {\n    return 'ai_victory';\n  } else if (aiEliminated) {\n    return 'player_victory';\n  } else {\n    return 'ongoing';\n  }\n}","import { PlayerState, BuildableType, UnitType } from './PlayerState.js';\nimport { GameState, FleetComposition } from './GameState.js';\n\nexport type AIArchetype = 'aggressor' | 'economist' | 'trickster' | 'hybrid';\n\nexport interface AIDecision {\n  type: 'build' | 'attack' | 'scan' | 'wait';\n  buildType?: BuildableType;\n  buildQuantity?: number;\n  attackTarget?: string;\n  attackFleet?: FleetComposition;\n  scanType?: 'basic' | 'deep' | 'advanced';\n}\n\nexport interface AIBehaviorProbabilities {\n  militaryFocus: number;\n  economicFocus: number;\n  aggressionLevel: number;\n  deceptionChance: number;\n  adaptiveVariation: number;\n}\n\nexport interface AIState extends PlayerState {\n  archetype: AIArchetype;\n  behaviorProbabilities: AIBehaviorProbabilities;\n  lastPlayerAction?: AIDecision;\n  threatLevel: number; // 0-1 scale based on player military strength\n  economicAdvantage: number; // -1 to 1 scale comparing economies\n}\n\nexport abstract class BaseAIArchetype {\n  protected archetype: AIArchetype;\n  protected behaviorProbabilities: AIBehaviorProbabilities;\n\n  constructor(archetype: AIArchetype, probabilities: AIBehaviorProbabilities) {\n    this.archetype = archetype;\n    this.behaviorProbabilities = probabilities;\n  }\n\n  abstract makeDecision(gameState: GameState, aiState: AIState): AIDecision;\n\n  protected calculateThreatLevel(gameState: GameState, aiState: AIState): number {\n    const playerFleet = gameState.player.fleet.homeSystem;\n    const aiFleet = aiState.fleet.homeSystem;\n    \n    const playerStrength = this.calculateFleetStrength(playerFleet);\n    const aiStrength = this.calculateFleetStrength(aiFleet);\n    \n    if (aiStrength === 0) return 1.0; // Maximum threat if AI has no fleet\n    \n    const ratio = playerStrength / aiStrength;\n    return Math.min(1.0, Math.max(0.0, ratio - 0.5)); // Normalize to 0-1 scale\n  }\n\n  protected calculateEconomicAdvantage(gameState: GameState, aiState: AIState): number {\n    const playerIncome = gameState.player.resources.metalIncome + gameState.player.resources.energyIncome;\n    const aiIncome = aiState.resources.metalIncome + aiState.resources.energyIncome;\n    \n    if (playerIncome + aiIncome === 0) return 0;\n    \n    return (aiIncome - playerIncome) / (aiIncome + playerIncome);\n  }\n\n  protected calculateFleetStrength(fleet: FleetComposition): number {\n    // Weighted strength calculation based on unit costs and effectiveness\n    return fleet.frigates * 1 + fleet.cruisers * 2.5 + fleet.battleships * 5;\n  }\n\n  protected shouldAdaptBehavior(): boolean {\n    return Math.random() < this.behaviorProbabilities.adaptiveVariation;\n  }\n\n  protected canAffordBuild(resources: PlayerState['resources'], buildType: BuildableType, quantity: number = 1): boolean {\n    const costs = this.getBuildCosts(buildType);\n    return resources.metal >= costs.metal * quantity && \n           resources.energy >= costs.energy * quantity;\n  }\n\n  protected getBuildCosts(buildType: BuildableType): { metal: number; energy: number } {\n    const costs = {\n      frigate: { metal: 4, energy: 2 },\n      cruiser: { metal: 10, energy: 6 },\n      battleship: { metal: 20, energy: 12 },\n      reactor: { metal: 900, energy: 1200 },\n      mine: { metal: 1500, energy: 600 }\n    };\n    \n    return costs[buildType];\n  }\n\n  protected getOptimalFleetComposition(targetStrength: number, threatType?: FleetComposition): FleetComposition {\n    // Simple composition logic - can be enhanced later\n    if (threatType) {\n      // Counter the dominant unit type\n      const dominantUnit = this.getDominantUnitType(threatType);\n      return this.getCounterComposition(dominantUnit, targetStrength);\n    }\n    \n    // Default balanced composition\n    const frigateCount = Math.floor(targetStrength * 0.5);\n    const cruiserCount = Math.floor(targetStrength * 0.3);\n    const battleshipCount = Math.floor(targetStrength * 0.2);\n    \n    return {\n      frigates: frigateCount,\n      cruisers: cruiserCount,\n      battleships: battleshipCount\n    };\n  }\n\n  protected getDominantUnitType(fleet: FleetComposition): UnitType {\n    const total = fleet.frigates + fleet.cruisers + fleet.battleships;\n    if (total === 0) return 'frigate';\n    \n    const frigateRatio = fleet.frigates / total;\n    const cruiserRatio = fleet.cruisers / total;\n    const battleshipRatio = fleet.battleships / total;\n    \n    if (frigateRatio >= cruiserRatio && frigateRatio >= battleshipRatio) return 'frigate';\n    if (cruiserRatio >= battleshipRatio) return 'cruiser';\n    return 'battleship';\n  }\n\n  private getCounterComposition(dominantUnit: UnitType, strength: number): FleetComposition {\n    // Rock-paper-scissors counters: Frigate > Cruiser > Battleship > Frigate\n    switch (dominantUnit) {\n      case 'frigate':\n        return { frigates: 0, cruisers: 0, battleships: Math.floor(strength) };\n      case 'cruiser':\n        return { frigates: Math.floor(strength), cruisers: 0, battleships: 0 };\n      case 'battleship':\n        return { frigates: 0, cruisers: Math.floor(strength), battleships: 0 };\n    }\n  }\n\n  protected validateDecision(decision: AIDecision, aiState: AIState): boolean {\n    switch (decision.type) {\n      case 'build':\n        if (!decision.buildType || !decision.buildQuantity) return false;\n        return this.canAffordBuild(aiState.resources, decision.buildType, decision.buildQuantity);\n      \n      case 'attack':\n        if (!decision.attackFleet || !decision.attackTarget) return false;\n        return this.hasAvailableFleet(aiState, decision.attackFleet);\n      \n      case 'scan':\n        if (!decision.scanType) return false;\n        const scanCosts = { basic: 1000, deep: 2500, advanced: 4000 };\n        return aiState.resources.energy >= scanCosts[decision.scanType];\n      \n      case 'wait':\n        return true;\n      \n      default:\n        return false;\n    }\n  }\n\n  protected hasAvailableFleet(aiState: AIState, requiredFleet: FleetComposition): boolean {\n    const available = aiState.fleet.homeSystem;\n    return available.frigates >= requiredFleet.frigates &&\n           available.cruisers >= requiredFleet.cruisers &&\n           available.battleships >= requiredFleet.battleships;\n  }\n}","import { FleetComposition } from './GameState.js';\n\nexport type ScanType = 'basic' | 'deep' | 'advanced';\n\nexport interface Intelligence {\n  lastScanTurn: number;\n  knownEnemyFleet: FleetComposition;\n  scanAccuracy: number;\n  scanHistory?: ScanResult[];\n  misinformationChance?: number;\n  lastScanData?: ScanResult | null;\n  misinformationActive?: boolean;\n}\n\nexport interface ScanResult {\n  scanType: ScanType;\n  timestamp: number;\n  fleetData?: Partial<FleetComposition>;\n  economicData?: {\n    reactors: number;\n    mines: number;\n  };\n  strategicIntent?: string;\n  accuracy: number;\n  isMisinformation?: boolean;\n  dataAge: number; // turns since scan was performed\n}\n\nexport interface IntelligenceGap {\n  lastKnownFleet: FleetComposition;\n  lastScanTurn: number;\n  estimatedInTransit: number; // estimated ships that might be in transit\n  confidence: number; // 0-1, decreases over time\n}\n\nexport interface ScanCosts {\n  basic: { metal: 0, energy: 1000 };\n  deep: { metal: 0, energy: 2500 };\n  advanced: { metal: 0, energy: 4000 };\n}\n\nexport const SCAN_COSTS: ScanCosts = {\n  basic: { metal: 0, energy: 1000 },\n  deep: { metal: 0, energy: 2500 },\n  advanced: { metal: 0, energy: 4000 }\n};\n\nexport const MISINFORMATION_BASE_CHANCE = 0.2; // 20% base chance\nexport const CONFIDENCE_DECAY_RATE = 0.1; // 10% confidence loss per turn","import { GameState, GamePhase, PlayerState, Resources, Fleet, Economy } from './index.js';\n\n/**\n * Validation functions for game state management and data integrity\n */\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\n/**\n * Validates a complete GameState object\n */\nexport function validateGameState(gameState: GameState): ValidationResult {\n  const errors: string[] = [];\n\n  // Validate turn number\n  if (gameState.turn < 1) {\n    errors.push('Turn number must be at least 1');\n  }\n\n  // Validate game phase consistency with turn number\n  const phaseValidation = validateGamePhase(gameState.gamePhase, gameState.turn);\n  if (!phaseValidation.isValid) {\n    errors.push(...phaseValidation.errors);\n  }\n\n  // Validate player state\n  const playerValidation = validatePlayerState(gameState.player);\n  if (!playerValidation.isValid) {\n    errors.push(...playerValidation.errors.map(err => `Player: ${err}`));\n  }\n\n  // Validate AI state\n  const aiValidation = validatePlayerState(gameState.ai);\n  if (!aiValidation.isValid) {\n    errors.push(...aiValidation.errors.map(err => `AI: ${err}`));\n  }\n\n  // Validate game over conditions\n  if (gameState.isGameOver) {\n    if (!gameState.winner) {\n      errors.push('Game over state requires a winner');\n    }\n    if (!gameState.victoryType) {\n      errors.push('Game over state requires a victory type');\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validates game phase transitions based on turn number\n */\nexport function validateGamePhase(phase: GamePhase, turn: number): ValidationResult {\n  const errors: string[] = [];\n\n  // Define phase boundaries based on typical game progression\n  if (turn <= 5 && phase !== 'early') {\n    errors.push(`Turn ${turn} should be in 'early' phase, but is '${phase}'`);\n  } else if (turn > 5 && turn <= 15 && phase !== 'mid') {\n    errors.push(`Turn ${turn} should be in 'mid' phase, but is '${phase}'`);\n  } else if (turn > 15 && turn <= 25 && phase !== 'late') {\n    errors.push(`Turn ${turn} should be in 'late' phase, but is '${phase}'`);\n  } else if (turn > 25 && phase !== 'endgame') {\n    errors.push(`Turn ${turn} should be in 'endgame' phase, but is '${phase}'`);\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validates PlayerState for data integrity\n */\nexport function validatePlayerState(playerState: PlayerState): ValidationResult {\n  const errors: string[] = [];\n\n  // Validate resources\n  const resourceValidation = validateResources(playerState.resources);\n  if (!resourceValidation.isValid) {\n    errors.push(...resourceValidation.errors);\n  }\n\n  // Validate fleet\n  const fleetValidation = validateFleet(playerState.fleet);\n  if (!fleetValidation.isValid) {\n    errors.push(...fleetValidation.errors);\n  }\n\n  // Validate economy\n  const economyValidation = validateEconomy(playerState.economy);\n  if (!economyValidation.isValid) {\n    errors.push(...economyValidation.errors);\n  }\n\n  // Validate intelligence data\n  if (playerState.intelligence.lastScanTurn < 0) {\n    errors.push('Last scan turn cannot be negative');\n  }\n\n  if (playerState.intelligence.scanAccuracy < 0 || playerState.intelligence.scanAccuracy > 1) {\n    errors.push('Scan accuracy must be between 0 and 1');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validates resource values and income rates\n */\nexport function validateResources(resources: Resources): ValidationResult {\n  const errors: string[] = [];\n\n  // Resources can be negative (debt), but should have reasonable bounds\n  if (resources.metal < -100000) {\n    errors.push('Metal resources are unreasonably negative');\n  }\n\n  if (resources.energy < -100000) {\n    errors.push('Energy resources are unreasonably negative');\n  }\n\n  // Income rates can be negative (indicating net loss)\n  if (resources.metalIncome < -50000) {\n    errors.push('Metal income is unreasonably negative');\n  }\n\n  if (resources.energyIncome < -50000) {\n    errors.push('Energy income is unreasonably negative');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validates fleet composition and movement data\n */\nexport function validateFleet(fleet: Fleet): ValidationResult {\n  const errors: string[] = [];\n\n  // Validate home system fleet counts\n  if (fleet.homeSystem.frigates < 0) {\n    errors.push('Frigate count cannot be negative');\n  }\n  if (fleet.homeSystem.cruisers < 0) {\n    errors.push('Cruiser count cannot be negative');\n  }\n  if (fleet.homeSystem.battleships < 0) {\n    errors.push('Battleship count cannot be negative');\n  }\n\n  // Validate in-transit fleets\n  for (const movement of fleet.inTransit.outbound) {\n    if (movement.composition.frigates < 0 || movement.composition.cruisers < 0 || movement.composition.battleships < 0) {\n      errors.push('In-transit fleet composition cannot have negative values');\n    }\n\n    if (movement.arrivalTurn <= 0) {\n      errors.push('Arrival turn must be positive');\n    }\n\n    if (movement.returnTurn <= movement.arrivalTurn) {\n      errors.push('Return turn must be after arrival turn');\n    }\n\n    if (!['outbound', 'combat', 'returning'].includes(movement.missionType)) {\n      errors.push(`Invalid mission type: ${movement.missionType}`);\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validates economy state including structures and construction queue\n */\nexport function validateEconomy(economy: Economy): ValidationResult {\n  const errors: string[] = [];\n\n  // Validate structure counts\n  if (economy.reactors < 0) {\n    errors.push('Reactor count cannot be negative');\n  }\n\n  if (economy.mines < 0) {\n    errors.push('Mine count cannot be negative');\n  }\n\n  // Validate construction queue\n  for (const buildOrder of economy.constructionQueue) {\n    if (buildOrder.quantity <= 0) {\n      errors.push('Build order quantity must be positive');\n    }\n\n    if (buildOrder.turnsRemaining < 0) {\n      errors.push('Turns remaining cannot be negative');\n    }\n\n    if (buildOrder.resourceDrainPerTurn.metal < 0 || buildOrder.resourceDrainPerTurn.energy < 0) {\n      errors.push('Resource drain per turn cannot be negative');\n    }\n\n    const validTypes = ['frigate', 'cruiser', 'battleship', 'reactor', 'mine'];\n    if (!validTypes.includes(buildOrder.unitType)) {\n      errors.push(`Invalid unit type in build order: ${buildOrder.unitType}`);\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validates state transitions between turns\n */\nexport function validateStateTransition(previousState: GameState, newState: GameState): ValidationResult {\n  const errors: string[] = [];\n\n  // Turn must increment by exactly 1\n  if (newState.turn !== previousState.turn + 1) {\n    errors.push(`Turn must increment by 1, got ${previousState.turn} -> ${newState.turn}`);\n  }\n\n  // Game phase can only progress forward or stay the same\n  const phaseOrder: GamePhase[] = ['early', 'mid', 'late', 'endgame'];\n  const prevPhaseIndex = phaseOrder.indexOf(previousState.gamePhase);\n  const newPhaseIndex = phaseOrder.indexOf(newState.gamePhase);\n\n  if (newPhaseIndex < prevPhaseIndex) {\n    errors.push(`Game phase cannot regress from ${previousState.gamePhase} to ${newState.gamePhase}`);\n  }\n\n  // Once game is over, it cannot become active again\n  if (previousState.isGameOver && !newState.isGameOver) {\n    errors.push('Game cannot become active after being over');\n  }\n\n  // Winner cannot change once set\n  if (previousState.winner && newState.winner && previousState.winner !== newState.winner) {\n    errors.push('Winner cannot change once determined');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Creates a new GameState with validated initial values\n */\nexport function createInitialGameState(playerState: PlayerState, aiState: PlayerState): GameState {\n  const gameState: GameState = {\n    turn: 1,\n    player: playerState,\n    ai: aiState,\n    combatLog: [],\n    gamePhase: 'early',\n    isGameOver: false\n  };\n\n  const validation = validateGameState(gameState);\n  if (!validation.isValid) {\n    throw new Error(`Invalid initial game state: ${validation.errors.join(', ')}`);\n  }\n\n  return gameState;\n}\n\n/**\n * Determines the appropriate game phase based on turn number\n */\nexport function determineGamePhase(turn: number): GamePhase {\n  if (turn <= 5) return 'early';\n  if (turn <= 15) return 'mid';\n  if (turn <= 25) return 'late';\n  return 'endgame';\n}"],"names":["STRUCTURE_STATS","reactor","buildCost","metal","energy","buildTime","incomeBonus","mine","BASE_INCOME","validateBuildOrder","buildOrder","errors","quantity","push","turnsRemaining","resourceDrainPerTurn","includes","unitType","isValid","length","calculateStructureCost","structureType","currentCount","baseCost","multiplier","Math","pow","ceil","calculateStructureIncome","reactors","mines","calculateConstructionDrain","constructionQueue","totalMetalDrain","totalEnergyDrain","calculateNetIncome","structureIncome","constructionDrain","createStructureBuildOrder","cost","createUnitBuildOrder","unitStats","processConstructionQueue","queue","completedOrders","remainingQueue","order","updatedOrder","canAffordBuildOrder","resources","totalMetalCost","totalEnergyCost","canSustainBuildOrder","netIncome","isStructureViable","maxPaybackTurns","paybackTime","Infinity","calculateStructurePaybackTime","UNIT_STATS","frigate","upkeepCost","effectiveness","vsFrigate","vsCruiser","vsBattleship","cruiser","battleship","getTotalFleetSize","composition","frigates","cruisers","battleships","calculateFleetUpkeep","generateRandomFactor","random","calculateUnitTypeStrength","unitCount","enemyComposition","randomFactor","stats","calculateFleetStrength","attacker","defender","randomFactors","factors","updateFleetMissionType","movement","currentTurn","missionType","arrivalTurn","processFleetMovements","movements","updated","combatMovements","returning","updatedMovement","calculateCasualties","fleet","outcome","isWinner","casualtyRate","frigatesCasualties","floor","cruisersCasualties","battleshipsCasualties","casualties","survivors","checkFleetElimination","homeFleet","outboundMovements","processCombatMovement","defenderHomeFleet","combatResult","attackerStrength","defenderStrength","ratio","determineBattleOutcome","attackerResult","defenderResult","strengthRatio","attackerSurvivors","defenderSurvivors","attackerCasualties","defenderCasualties","resolveCombat","returningFleet","originalMovement","target","returnTurn","createReturningFleet","updatedDefenderFleet","BaseAIArchetype","constructor","archetype","probabilities","__publicField","this","behaviorProbabilities","calculateThreatLevel","gameState","aiState","playerFleet","player","homeSystem","aiFleet","playerStrength","aiStrength","min","max","calculateEconomicAdvantage","playerIncome","metalIncome","energyIncome","aiIncome","shouldAdaptBehavior","adaptiveVariation","canAffordBuild","buildType","costs","getBuildCosts","getOptimalFleetComposition","targetStrength","threatType","dominantUnit","getDominantUnitType","getCounterComposition","total","frigateRatio","cruiserRatio","battleshipRatio","strength","validateDecision","decision","type","buildQuantity","attackFleet","attackTarget","hasAvailableFleet","scanType","scanCosts","basic","deep","advanced","requiredFleet","available","SCAN_COSTS","MISINFORMATION_BASE_CHANCE","CONFIDENCE_DECAY_RATE","validateGameState","turn","phaseValidation","phase","validateGamePhase","gamePhase","playerValidation","validatePlayerState","map","err","aiValidation","ai","isGameOver","winner","victoryType","playerState","resourceValidation","validateResources","fleetValidation","inTransit","outbound","validateFleet","economyValidation","economy","validateEconomy","intelligence","lastScanTurn","scanAccuracy"],"mappings":"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"}