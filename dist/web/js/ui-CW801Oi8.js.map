{"version":3,"file":"ui-CW801Oi8.js","sources":["../../../src/ui/ColorManager.ts","../../../src/ui/TacticalAnalyzer.ts","../../../src/ui/GameDisplay.ts","../../../src/ui/InputHandler.ts","../../../src/ui/GameController.ts","../../../src/ErrorHandler.ts","../../../src/ui/CLIInterface.ts"],"sourcesContent":["import { FleetComposition } from '../models/GameState.js';\n\n/**\n * Color theme interface defining ANSI color codes for different UI elements\n */\nexport interface ColorTheme {\n  victory: string;      // Green for victories\n  defeat: string;       // Red for defeats\n  neutral: string;      // Yellow for close battles\n  player: string;       // Blue for player actions\n  enemy: string;        // Magenta for AI actions\n  frigate: string;      // Cyan for frigates\n  cruiser: string;      // Yellow for cruisers\n  battleship: string;   // Red for battleships\n  casualties: string;   // Bright red for losses\n  survivors: string;    // Green for remaining forces\n  reset: string;        // Reset color code\n}\n\n/**\n * Configuration options for combat display\n */\nexport interface CombatDisplayOptions {\n  showTacticalAnalysis: boolean;\n  showBattlePhases: boolean;\n  useColors: boolean;\n  detailedCasualties: boolean;\n}\n\n/**\n * Color Manager utility class for consistent color coding across combat displays\n */\nexport class ColorManager {\n  private theme: ColorTheme;\n  private colorsEnabled: boolean;\n  private colorSupported: boolean;\n\n  constructor(enableColors: boolean = true) {\n    this.theme = this.getDefaultTheme();\n    this.colorSupported = this.detectColorSupport();\n    this.colorsEnabled = enableColors && this.colorSupported;\n  }\n\n  /**\n   * Returns the default color theme with ANSI color codes\n   */\n  private getDefaultTheme(): ColorTheme {\n    return {\n      victory: '\\x1b[32m',      // Green\n      defeat: '\\x1b[31m',       // Red\n      neutral: '\\x1b[33m',      // Yellow\n      player: '\\x1b[34m',       // Blue\n      enemy: '\\x1b[35m',        // Magenta\n      frigate: '\\x1b[36m',      // Cyan\n      cruiser: '\\x1b[33m',      // Yellow\n      battleship: '\\x1b[31m',   // Red\n      casualties: '\\x1b[91m',   // Bright red\n      survivors: '\\x1b[92m',    // Bright green\n      reset: '\\x1b[0m'          // Reset\n    };\n  }\n\n  /**\n   * Validates and sanitizes numeric values with optional bounds checking\n   */\n  private validateNumericValue(value: any, fieldName: string, min: number = 0, max: number = Number.MAX_SAFE_INTEGER): number {\n    if (typeof value !== 'number' || isNaN(value) || !isFinite(value)) {\n      console.warn(`ColorManager.validateNumericValue: Invalid ${fieldName} value '${value}', using 0`);\n      return 0;\n    }\n\n    if (value < min) {\n      console.warn(`ColorManager.validateNumericValue: ${fieldName} value ${value} below minimum ${min}, using ${min}`);\n      return min;\n    }\n\n    if (value > max) {\n      console.warn(`ColorManager.validateNumericValue: ${fieldName} value ${value} above maximum ${max}, using ${max}`);\n      return max;\n    }\n\n    return Math.floor(value); // Ensure integer values\n  }\n\n  /**\n   * Detects if the terminal supports color output\n   */\n  private detectColorSupport(): boolean {\n    // Check common environment variables that indicate color support\n    const colorTerms = ['color', 'ansi', 'truecolor', '256color'];\n    const term = process.env.TERM?.toLowerCase() || '';\n    const colorTerm = process.env.COLORTERM?.toLowerCase() || '';\n    \n    // Check if TERM or COLORTERM contains color indicators\n    const hasColorTerm = colorTerms.some(colorType => \n      term.includes(colorType) || colorTerm.includes(colorType)\n    );\n    \n    // Check for explicit color support variables\n    const forceColor = process.env.FORCE_COLOR;\n    const noColor = process.env.NO_COLOR;\n    \n    // Explicit disable takes precedence\n    if (noColor) {\n      return false;\n    }\n    \n    // Explicit enable\n    if (forceColor) {\n      return true;\n    }\n    \n    // Check if we're in a TTY and have color term\n    const isTTY = process.stdout.isTTY;\n    \n    return isTTY && (hasColorTerm || term !== 'dumb');\n  }\n\n  /**\n   * Applies color to text if colors are enabled\n   */\n  public colorize(text: string, colorType: keyof ColorTheme): string {\n    // Validate input parameters\n    if (typeof text !== 'string') {\n      console.warn('ColorManager.colorize: text parameter must be a string, received:', typeof text);\n      return String(text || '');\n    }\n\n    if (!this.colorsEnabled) {\n      return text;\n    }\n\n    try {\n      const colorCode = this.theme[colorType];\n      const resetCode = this.theme.reset;\n      \n      // Validate color codes exist\n      if (!colorCode || !resetCode) {\n        console.warn(`ColorManager.colorize: Missing color code for type '${colorType}', falling back to plain text`);\n        return text;\n      }\n      \n      return `${colorCode}${text}${resetCode}`;\n    } catch (error) {\n      console.warn('ColorManager.colorize: Error applying colors, falling back to plain text:', error);\n      return text;\n    }\n  }\n\n  /**\n   * Formats fleet composition with color coding for unit types\n   */\n  public formatFleetComposition(fleet: FleetComposition, showColors: boolean = true): string {\n    // Validate fleet composition data\n    if (!fleet || typeof fleet !== 'object') {\n      console.warn('ColorManager.formatFleetComposition: Invalid fleet composition data, using defaults');\n      fleet = { frigates: 0, cruisers: 0, battleships: 0 };\n    }\n\n    // Ensure numeric values and handle invalid data\n    const frigates = this.validateNumericValue(fleet.frigates, 'frigates');\n    const cruisers = this.validateNumericValue(fleet.cruisers, 'cruisers');\n    const battleships = this.validateNumericValue(fleet.battleships, 'battleships');\n\n    if (!showColors || !this.colorsEnabled) {\n      return `${frigates}F, ${cruisers}C, ${battleships}B`;\n    }\n    \n    try {\n      const frigateText = this.colorize(`${frigates}F`, 'frigate');\n      const cruiserText = this.colorize(`${cruisers}C`, 'cruiser');\n      const battleshipText = this.colorize(`${battleships}B`, 'battleship');\n      \n      return `${frigateText}, ${cruiserText}, ${battleshipText}`;\n    } catch (error) {\n      console.warn('ColorManager.formatFleetComposition: Error formatting with colors, falling back to plain text:', error);\n      return `${frigates}F, ${cruisers}C, ${battleships}B`;\n    }\n  }\n\n  /**\n   * Formats battle outcome with appropriate colors\n   */\n  public formatBattleOutcome(outcome: string, perspective: 'attacker' | 'defender'): string {\n    // Validate input parameters\n    if (typeof outcome !== 'string') {\n      console.warn('ColorManager.formatBattleOutcome: Invalid outcome type, using default');\n      outcome = 'unknown_outcome';\n    }\n\n    if (perspective !== 'attacker' && perspective !== 'defender') {\n      console.warn('ColorManager.formatBattleOutcome: Invalid perspective, defaulting to attacker');\n      perspective = 'attacker';\n    }\n\n    const formattedOutcome = outcome.toUpperCase().replace(/_/g, ' ');\n\n    if (!this.colorsEnabled) {\n      return formattedOutcome;\n    }\n    \n    try {\n      let colorType: keyof ColorTheme;\n      \n      switch (outcome) {\n        case 'decisive_attacker':\n          colorType = perspective === 'attacker' ? 'victory' : 'defeat';\n          break;\n        case 'decisive_defender':\n          colorType = perspective === 'defender' ? 'victory' : 'defeat';\n          break;\n        case 'close_battle':\n          colorType = 'neutral';\n          break;\n        default:\n          console.warn(`ColorManager.formatBattleOutcome: Unknown outcome '${outcome}', using neutral color`);\n          colorType = 'neutral';\n      }\n      \n      return this.colorize(formattedOutcome, colorType);\n    } catch (error) {\n      console.warn('ColorManager.formatBattleOutcome: Error formatting outcome, falling back to plain text:', error);\n      return formattedOutcome;\n    }\n  }\n\n  /**\n   * Formats casualty information with warning colors\n   */\n  public formatCasualties(casualties: number, total: number): string {\n    // Validate and sanitize input values\n    const validCasualties = this.validateNumericValue(casualties, 'casualties');\n    const validTotal = this.validateNumericValue(total, 'total');\n    \n    const percentage = validTotal > 0 ? Math.round((validCasualties / validTotal) * 100) : 0;\n    const casualtyText = `${validCasualties} ships (${percentage}%)`;\n    \n    if (!this.colorsEnabled) {\n      return casualtyText;\n    }\n    \n    try {\n      return this.colorize(casualtyText, 'casualties');\n    } catch (error) {\n      console.warn('ColorManager.formatCasualties: Error formatting casualties, falling back to plain text:', error);\n      return casualtyText;\n    }\n  }\n\n  /**\n   * Formats survivor information with positive colors\n   */\n  public formatSurvivors(survivors: number): string {\n    // Validate and sanitize input value\n    const validSurvivors = this.validateNumericValue(survivors, 'survivors');\n    const survivorText = `${validSurvivors} ships`;\n    \n    if (!this.colorsEnabled) {\n      return survivorText;\n    }\n    \n    try {\n      return this.colorize(survivorText, 'survivors');\n    } catch (error) {\n      console.warn('ColorManager.formatSurvivors: Error formatting survivors, falling back to plain text:', error);\n      return survivorText;\n    }\n  }\n\n  /**\n   * Formats player/AI identification with distinct colors\n   */\n  public formatPlayerIdentifier(playerType: 'player' | 'ai', text: string): string {\n    // Validate input parameters\n    if (typeof text !== 'string') {\n      console.warn('ColorManager.formatPlayerIdentifier: text parameter must be a string');\n      text = String(text || '');\n    }\n\n    if (playerType !== 'player' && playerType !== 'ai') {\n      console.warn('ColorManager.formatPlayerIdentifier: Invalid playerType, defaulting to player');\n      playerType = 'player';\n    }\n\n    if (!this.colorsEnabled) {\n      return text;\n    }\n    \n    try {\n      const colorType = playerType === 'player' ? 'player' : 'enemy';\n      return this.colorize(text, colorType);\n    } catch (error) {\n      console.warn('ColorManager.formatPlayerIdentifier: Error formatting identifier, falling back to plain text:', error);\n      return text;\n    }\n  }\n\n  /**\n   * Creates a colored separator line\n   */\n  public createSeparator(length: number = 60, char: string = '-'): string {\n    // Validate and sanitize input parameters\n    const validLength = this.validateNumericValue(length, 'length', 1, 200);\n    \n    if (typeof char !== 'string' || char.length === 0) {\n      console.warn('ColorManager.createSeparator: Invalid character, using default');\n      char = '-';\n    }\n\n    // Use only the first character to prevent excessive memory usage\n    const safeChar = char.charAt(0);\n    \n    try {\n      const separator = safeChar.repeat(validLength);\n      \n      if (!this.colorsEnabled) {\n        return separator;\n      }\n      \n      return this.colorize(separator, 'neutral');\n    } catch (error) {\n      console.warn('ColorManager.createSeparator: Error creating separator, falling back to simple separator:', error);\n      return '-'.repeat(Math.min(validLength, 60));\n    }\n  }\n\n  /**\n   * Enables or disables color output\n   */\n  public setColorsEnabled(enabled: boolean): void {\n    this.colorsEnabled = enabled && this.colorSupported;\n  }\n\n  /**\n   * Returns whether colors are currently enabled\n   */\n  public areColorsEnabled(): boolean {\n    return this.colorsEnabled;\n  }\n\n  /**\n   * Returns whether the terminal supports colors\n   */\n  public isColorSupported(): boolean {\n    return this.colorSupported;\n  }\n\n  /**\n   * Sets a custom color theme\n   */\n  public setTheme(theme: Partial<ColorTheme>): void {\n    this.theme = { ...this.theme, ...theme };\n  }\n\n  /**\n   * Gets the current color theme\n   */\n  public getTheme(): ColorTheme {\n    return { ...this.theme };\n  }\n\n  /**\n   * Resets to the default color theme\n   */\n  public resetTheme(): void {\n    this.theme = this.getDefaultTheme();\n  }\n}\n\n/**\n * Default color manager instance\n */\nexport const defaultColorManager = new ColorManager();","import { FleetComposition, CombatEvent } from '../models/GameState.js';\nimport { UNIT_STATS, UnitType } from '../models/Fleet.js';\n\n/**\n * Represents tactical advantage information for a specific unit type\n */\nexport interface TacticalAdvantage {\n  unitType: UnitType;\n  advantage: 'strong' | 'weak' | 'neutral';\n  explanation: string;\n  effectivenessRatio: number;\n}\n\n/**\n * Represents battle phase information\n */\nexport interface BattlePhase {\n  phase: 'opening' | 'main' | 'cleanup';\n  description: string;\n  advantage: 'attacker' | 'defender' | 'neutral';\n  strengthRatio: number;\n}\n\n/**\n * Enhanced combat display information with tactical analysis\n */\nexport interface EnhancedCombatDisplay {\n  event: CombatEvent;\n  tacticalAdvantages: TacticalAdvantage[];\n  battlePhases: BattlePhase[];\n  effectivenessRatios: {\n    attackerEffectiveness: number;\n    defenderEffectiveness: number;\n  };\n  casualtyPercentages: {\n    attackerLossRate: number;\n    defenderLossRate: number;\n  };\n}\n\n/**\n * Tactical Analyzer utility class for calculating unit effectiveness and battle advantages\n */\nexport class TacticalAnalyzer {\n  \n  /**\n   * Calculates unit effectiveness for a specific unit type against enemy fleet composition\n   */\n  public calculateUnitEffectiveness(\n    unitType: UnitType,\n    unitCount: number,\n    enemyFleet: FleetComposition\n  ): number {\n    if (unitCount === 0) return 0;\n    \n    const stats = UNIT_STATS[unitType];\n    const totalEnemyUnits = enemyFleet.frigates + enemyFleet.cruisers + enemyFleet.battleships;\n    \n    if (totalEnemyUnits === 0) return 1.0; // Perfect effectiveness against empty fleet\n    \n    // Calculate weighted effectiveness based on enemy composition\n    const frigateWeight = enemyFleet.frigates / totalEnemyUnits;\n    const cruiserWeight = enemyFleet.cruisers / totalEnemyUnits;\n    const battleshipWeight = enemyFleet.battleships / totalEnemyUnits;\n    \n    const weightedEffectiveness = \n      (stats.effectiveness.vsFrigate * frigateWeight) +\n      (stats.effectiveness.vsCruiser * cruiserWeight) +\n      (stats.effectiveness.vsBattleship * battleshipWeight);\n    \n    return weightedEffectiveness;\n  }\n\n  /**\n   * Determines battle advantage for a specific unit type\n   */\n  public determineBattleAdvantage(\n    unitType: UnitType,\n    attackerCount: number,\n    defenderFleet: FleetComposition\n  ): TacticalAdvantage {\n    const effectiveness = this.calculateUnitEffectiveness(unitType, attackerCount, defenderFleet);\n    \n    let advantage: 'strong' | 'weak' | 'neutral';\n    let explanation: string;\n    \n    if (effectiveness >= 1.3) {\n      advantage = 'strong';\n      explanation = `${unitType}s have strong effectiveness against enemy composition`;\n    } else if (effectiveness <= 0.7) {\n      advantage = 'weak';\n      explanation = `${unitType}s are at a disadvantage against enemy composition`;\n    } else {\n      advantage = 'neutral';\n      explanation = `${unitType}s have balanced effectiveness against enemy composition`;\n    }\n    \n    return {\n      unitType,\n      advantage,\n      explanation,\n      effectivenessRatio: effectiveness\n    };\n  }\n\n  /**\n   * Calculates tactical advantages for entire fleet composition\n   */\n  public calculateTacticalAdvantages(\n    attackerFleet: FleetComposition,\n    defenderFleet: FleetComposition\n  ): TacticalAdvantage[] {\n    const advantages: TacticalAdvantage[] = [];\n    \n    // Analyze each unit type in attacker fleet\n    if (attackerFleet.frigates > 0) {\n      advantages.push(this.determineBattleAdvantage('frigate', attackerFleet.frigates, defenderFleet));\n    }\n    \n    if (attackerFleet.cruisers > 0) {\n      advantages.push(this.determineBattleAdvantage('cruiser', attackerFleet.cruisers, defenderFleet));\n    }\n    \n    if (attackerFleet.battleships > 0) {\n      advantages.push(this.determineBattleAdvantage('battleship', attackerFleet.battleships, defenderFleet));\n    }\n    \n    return advantages;\n  }\n\n  /**\n   * Calculates casualty percentages from combat event\n   */\n  public calculateCasualtyPercentages(event: CombatEvent): {\n    attackerLossRate: number;\n    defenderLossRate: number;\n  } {\n    const attackerTotal = event.attackerFleet.frigates + event.attackerFleet.cruisers + event.attackerFleet.battleships;\n    const defenderTotal = event.defenderFleet.frigates + event.defenderFleet.cruisers + event.defenderFleet.battleships;\n    \n    const attackerCasualties = event.casualties.attacker.frigates + event.casualties.attacker.cruisers + event.casualties.attacker.battleships;\n    const defenderCasualties = event.casualties.defender.frigates + event.casualties.defender.cruisers + event.casualties.defender.battleships;\n    \n    const attackerLossRate = attackerTotal > 0 ? (attackerCasualties / attackerTotal) : 0;\n    const defenderLossRate = defenderTotal > 0 ? (defenderCasualties / defenderTotal) : 0;\n    \n    return {\n      attackerLossRate: Math.round(attackerLossRate * 100) / 100, // Round to 2 decimal places\n      defenderLossRate: Math.round(defenderLossRate * 100) / 100\n    };\n  }\n\n  /**\n   * Calculates overall effectiveness ratios for both fleets\n   */\n  public calculateEffectivenessRatios(\n    attackerFleet: FleetComposition,\n    defenderFleet: FleetComposition\n  ): {\n    attackerEffectiveness: number;\n    defenderEffectiveness: number;\n  } {\n    // Calculate attacker effectiveness against defender\n    const attackerFrigateEff = this.calculateUnitEffectiveness('frigate', attackerFleet.frigates, defenderFleet);\n    const attackerCruiserEff = this.calculateUnitEffectiveness('cruiser', attackerFleet.cruisers, defenderFleet);\n    const attackerBattleshipEff = this.calculateUnitEffectiveness('battleship', attackerFleet.battleships, defenderFleet);\n    \n    const attackerTotal = attackerFleet.frigates + attackerFleet.cruisers + attackerFleet.battleships;\n    const attackerEffectiveness = attackerTotal > 0 ? \n      ((attackerFrigateEff * attackerFleet.frigates) + \n       (attackerCruiserEff * attackerFleet.cruisers) + \n       (attackerBattleshipEff * attackerFleet.battleships)) / attackerTotal : 0;\n    \n    // Calculate defender effectiveness against attacker\n    const defenderFrigateEff = this.calculateUnitEffectiveness('frigate', defenderFleet.frigates, attackerFleet);\n    const defenderCruiserEff = this.calculateUnitEffectiveness('cruiser', defenderFleet.cruisers, attackerFleet);\n    const defenderBattleshipEff = this.calculateUnitEffectiveness('battleship', defenderFleet.battleships, attackerFleet);\n    \n    const defenderTotal = defenderFleet.frigates + defenderFleet.cruisers + defenderFleet.battleships;\n    const defenderEffectiveness = defenderTotal > 0 ? \n      ((defenderFrigateEff * defenderFleet.frigates) + \n       (defenderCruiserEff * defenderFleet.cruisers) + \n       (defenderBattleshipEff * defenderFleet.battleships)) / defenderTotal : 0;\n    \n    return {\n      attackerEffectiveness: Math.round(attackerEffectiveness * 100) / 100,\n      defenderEffectiveness: Math.round(defenderEffectiveness * 100) / 100\n    };\n  }\n\n  /**\n   * Determines battle phases based on fleet compositions and outcome\n   */\n  public determineBattlePhases(\n    attackerFleet: FleetComposition,\n    defenderFleet: FleetComposition,\n    outcome: 'decisive_attacker' | 'decisive_defender' | 'close_battle'\n  ): BattlePhase[] {\n    const phases: BattlePhase[] = [];\n    \n    // Calculate overall strength ratio for phase determination\n    const attackerTotal = attackerFleet.frigates + attackerFleet.cruisers + attackerFleet.battleships;\n    const defenderTotal = defenderFleet.frigates + defenderFleet.cruisers + defenderFleet.battleships;\n    const strengthRatio = defenderTotal > 0 ? attackerTotal / defenderTotal : Infinity;\n    \n    // Opening phase - initial engagement\n    let openingAdvantage: 'attacker' | 'defender' | 'neutral';\n    let openingDescription: string;\n    \n    if (attackerFleet.frigates > defenderFleet.frigates * 1.5) {\n      openingAdvantage = 'attacker';\n      openingDescription = 'Attacker gains early advantage with superior frigate numbers';\n    } else if (defenderFleet.frigates > attackerFleet.frigates * 1.5) {\n      openingAdvantage = 'defender';\n      openingDescription = 'Defender controls opening with frigate superiority';\n    } else {\n      openingAdvantage = 'neutral';\n      openingDescription = 'Opening engagement is evenly matched';\n    }\n    \n    phases.push({\n      phase: 'opening',\n      description: openingDescription,\n      advantage: openingAdvantage,\n      strengthRatio: strengthRatio\n    });\n    \n    // Main phase - heavy engagement\n    let mainAdvantage: 'attacker' | 'defender' | 'neutral';\n    let mainDescription: string;\n    \n    const attackerHeavy = attackerFleet.cruisers + attackerFleet.battleships;\n    const defenderHeavy = defenderFleet.cruisers + defenderFleet.battleships;\n    \n    if (attackerHeavy > defenderHeavy * 1.3) {\n      mainAdvantage = 'attacker';\n      mainDescription = 'Attacker dominates with superior heavy units';\n    } else if (defenderHeavy > attackerHeavy * 1.3) {\n      mainAdvantage = 'defender';\n      mainDescription = 'Defender holds firm with heavy unit advantage';\n    } else {\n      mainAdvantage = 'neutral';\n      mainDescription = 'Main engagement sees fierce fighting on both sides';\n    }\n    \n    phases.push({\n      phase: 'main',\n      description: mainDescription,\n      advantage: mainAdvantage,\n      strengthRatio: strengthRatio\n    });\n    \n    // Cleanup phase - battle resolution\n    let cleanupAdvantage: 'attacker' | 'defender' | 'neutral';\n    let cleanupDescription: string;\n    \n    switch (outcome) {\n      case 'decisive_attacker':\n        cleanupAdvantage = 'attacker';\n        cleanupDescription = 'Attacker achieves decisive victory in final phase';\n        break;\n      case 'decisive_defender':\n        cleanupAdvantage = 'defender';\n        cleanupDescription = 'Defender successfully repels attack in final phase';\n        break;\n      case 'close_battle':\n        cleanupAdvantage = 'neutral';\n        cleanupDescription = 'Battle concludes with heavy losses on both sides';\n        break;\n    }\n    \n    phases.push({\n      phase: 'cleanup',\n      description: cleanupDescription,\n      advantage: cleanupAdvantage,\n      strengthRatio: strengthRatio\n    });\n    \n    return phases;\n  }\n\n  /**\n   * Creates enhanced combat display with full tactical analysis\n   */\n  public createEnhancedCombatDisplay(event: CombatEvent): EnhancedCombatDisplay {\n    const tacticalAdvantages = this.calculateTacticalAdvantages(event.attackerFleet, event.defenderFleet);\n    const battlePhases = this.determineBattlePhases(event.attackerFleet, event.defenderFleet, event.outcome);\n    const effectivenessRatios = this.calculateEffectivenessRatios(event.attackerFleet, event.defenderFleet);\n    const casualtyPercentages = this.calculateCasualtyPercentages(event);\n    \n    return {\n      event,\n      tacticalAdvantages,\n      battlePhases,\n      effectivenessRatios,\n      casualtyPercentages\n    };\n  }\n\n  /**\n   * Analyzes fleet composition balance and provides recommendations\n   */\n  public analyzeFleetBalance(fleet: FleetComposition): {\n    balance: 'balanced' | 'frigate_heavy' | 'cruiser_heavy' | 'battleship_heavy' | 'unbalanced';\n    recommendation: string;\n    strengths: string[];\n    weaknesses: string[];\n  } {\n    const total = fleet.frigates + fleet.cruisers + fleet.battleships;\n    \n    if (total === 0) {\n      return {\n        balance: 'unbalanced',\n        recommendation: 'Build a fleet to defend your system',\n        strengths: [],\n        weaknesses: ['No defensive capability']\n      };\n    }\n    \n    const frigateRatio = fleet.frigates / total;\n    const cruiserRatio = fleet.cruisers / total;\n    const battleshipRatio = fleet.battleships / total;\n    \n    const strengths: string[] = [];\n    const weaknesses: string[] = [];\n    \n    // Analyze composition\n    if (frigateRatio > 0.6) {\n      strengths.push('Fast response capability');\n      strengths.push('Cost-effective against cruisers');\n      weaknesses.push('Vulnerable to battleships');\n      return {\n        balance: 'frigate_heavy',\n        recommendation: 'Consider adding battleships for better balance',\n        strengths,\n        weaknesses\n      };\n    }\n    \n    if (cruiserRatio > 0.5) {\n      strengths.push('Strong against battleships');\n      strengths.push('Balanced offensive capability');\n      weaknesses.push('Vulnerable to frigate swarms');\n      return {\n        balance: 'cruiser_heavy',\n        recommendation: 'Add frigates for anti-cruiser defense',\n        strengths,\n        weaknesses\n      };\n    }\n    \n    if (battleshipRatio > 0.4) {\n      strengths.push('Devastating against frigates');\n      strengths.push('High individual unit strength');\n      weaknesses.push('Vulnerable to cruiser focus fire');\n      weaknesses.push('High resource investment');\n      return {\n        balance: 'battleship_heavy',\n        recommendation: 'Add cruisers for better tactical flexibility',\n        strengths,\n        weaknesses\n      };\n    }\n    \n    // Balanced fleet\n    strengths.push('Tactical flexibility');\n    strengths.push('No major vulnerabilities');\n    return {\n      balance: 'balanced',\n      recommendation: 'Maintain current composition balance',\n      strengths,\n      weaknesses: ['Higher resource requirements for balance']\n    };\n  }\n}\n\n/**\n * Default tactical analyzer instance\n */\nexport const defaultTacticalAnalyzer = new TacticalAnalyzer();","import { GameState, FleetComposition, CombatEvent } from '../models/GameState.js';\nimport { PlayerState } from '../models/PlayerState.js';\nimport { TurnResult } from '../engine/GameEngine.js';\nimport { ColorManager } from './ColorManager.js';\nimport { TacticalAnalyzer } from './TacticalAnalyzer.js';\nimport { CLIConfig } from './CLIInterface.js';\n\nexport class GameDisplay {\n  private config: CLIConfig;\n  private colorManager: ColorManager;\n  private tacticalAnalyzer: TacticalAnalyzer;\n\n  constructor(config: CLIConfig = {}) {\n    this.config = {\n      // Set default combat display preferences\n      combatDisplay: {\n        showTacticalAnalysis: true,\n        showBattlePhases: true,\n        detailedCasualties: true,\n        useEnhancedFormatting: true,\n        ...config.combatDisplay\n      },\n      ...config\n    };\n    this.colorManager = new ColorManager(config.useColors !== false);\n    this.tacticalAnalyzer = new TacticalAnalyzer();\n  }\n\n  /**\n   * Displays the main game state information\n   */\n  public displayGameState(gameState: GameState): void {\n    console.log('\\n' + '='.repeat(60));\n    console.log(`TURN ${gameState.turn} | PHASE: ${gameState.gamePhase.toUpperCase()}`);\n    console.log('='.repeat(60));\n\n    // Display player resources and income\n    this.displayPlayerResources(gameState.player);\n    \n    // Display fleet information\n    this.displayFleetStatus(gameState.player);\n    \n    // Display construction queue\n    this.displayConstructionQueue(gameState.player);\n    \n    // Display intelligence information\n    this.displayIntelligence(gameState.player);\n    \n    console.log('-'.repeat(60));\n  }\n\n  /**\n   * Displays player resources and income\n   */\n  private displayPlayerResources(player: PlayerState): void {\n    const resources = player.resources;\n    const netMetal = resources.metalIncome;\n    const netEnergy = resources.energyIncome;\n    \n    console.log('\\nRESOURCES:');\n    console.log(`Metal:  ${this.formatNumber(resources.metal)} (${this.formatIncome(netMetal)}/turn)`);\n    console.log(`Energy: ${this.formatNumber(resources.energy)} (${this.formatIncome(netEnergy)}/turn)`);\n    \n    // Warn about economic stall\n    if (netMetal <= 0 || netEnergy <= 0) {\n      console.log('âš ï¸  WARNING: Economy stalled! Income is zero or negative.');\n    }\n  }\n\n  /**\n   * Displays fleet status including home and in-transit fleets\n   */\n  private displayFleetStatus(player: PlayerState): void {\n    const homeFleet = player.fleet.homeSystem;\n    const totalHome = homeFleet.frigates + homeFleet.cruisers + homeFleet.battleships;\n    \n    console.log('\\nFLEET STATUS:');\n    console.log(`Home Fleet (${totalHome} ships):`);\n    console.log(`  Frigates:    ${this.formatNumber(homeFleet.frigates)}`);\n    console.log(`  Cruisers:    ${this.formatNumber(homeFleet.cruisers)}`);\n    console.log(`  Battleships: ${this.formatNumber(homeFleet.battleships)}`);\n    \n    // Display in-transit fleets\n    const inTransit = player.fleet.inTransit.outbound;\n    if (inTransit.length > 0) {\n      console.log('\\nFLEETS IN TRANSIT:');\n      inTransit.forEach((movement, index) => {\n        const totalShips = movement.composition.frigates + movement.composition.cruisers + movement.composition.battleships;\n        const status = this.getFleetMovementStatus(movement);\n        console.log(`  Fleet ${index + 1}: ${totalShips} ships - ${status}`);\n      });\n    }\n  }\n\n  /**\n   * Displays construction queue\n   */\n  private displayConstructionQueue(player: PlayerState): void {\n    const queue = player.economy.constructionQueue;\n    \n    if (queue.length > 0) {\n      console.log('\\nCONSTRUCTION QUEUE:');\n      queue.forEach((order, index) => {\n        const progress = this.getConstructionProgress(order);\n        console.log(`  ${index + 1}. ${order.quantity}x ${order.unitType} - ${progress}`);\n      });\n    }\n    \n    // Display economic structures\n    const structures = player.economy;\n    if (structures.reactors > 0 || structures.mines > 0) {\n      console.log('\\nECONOMIC STRUCTURES:');\n      if (structures.reactors > 0) {\n        console.log(`  Reactors: ${structures.reactors} (+${structures.reactors * 500} Energy/turn)`);\n      }\n      if (structures.mines > 0) {\n        console.log(`  Mines: ${structures.mines} (+${structures.mines * 500} Metal/turn)`);\n      }\n    }\n  }\n\n  /**\n   * Displays intelligence information\n   */\n  private displayIntelligence(player: PlayerState): void {\n    const intel = player.intelligence;\n    \n    if (intel.lastScanTurn > 0) {\n      const turnsAgo = Math.max(0, intel.lastScanTurn);\n      console.log('\\nINTELLIGENCE:');\n      console.log(`Last scan: ${turnsAgo === 0 ? 'This turn' : `${turnsAgo} turns ago`}`);\n      \n      const knownFleet = intel.knownEnemyFleet;\n      const totalKnown = knownFleet.frigates + knownFleet.cruisers + knownFleet.battleships;\n      \n      if (totalKnown > 0) {\n        console.log(`Known enemy fleet (~${this.formatNumber(totalKnown)} ships):`);\n        console.log(`  Frigates:    ~${this.formatNumber(knownFleet.frigates)}`);\n        console.log(`  Cruisers:    ~${this.formatNumber(knownFleet.cruisers)}`);\n        console.log(`  Battleships: ~${this.formatNumber(knownFleet.battleships)}`);\n        \n        if (turnsAgo > 2) {\n          console.log('âš ï¸  Intelligence data may be outdated');\n        }\n      }\n    } else {\n      console.log('\\nINTELLIGENCE: No enemy scans performed');\n    }\n  }\n\n  /**\n   * Displays detailed game status\n   */\n  public displayDetailedStatus(gameState: GameState, stats: any): void {\n    console.log('\\n' + '='.repeat(60));\n    console.log('DETAILED GAME STATUS');\n    console.log('='.repeat(60));\n    \n    // Game information\n    console.log(`Turn: ${gameState.turn}`);\n    console.log(`Phase: ${gameState.gamePhase}`);\n    console.log(`Combat Events: ${stats.combatEvents}`);\n    \n    // Player vs AI comparison\n    console.log('\\nPLAYER vs AI COMPARISON:');\n    console.log('                    Player      AI');\n    console.log(`Fleet Size:         ${this.padNumber(stats.playerStats.totalFleetSize)}      ${stats.aiStats.totalFleetSize}`);\n    console.log(`Metal Income:       ${this.padNumber(stats.playerStats.netIncome.metal)}      ${stats.aiStats.netIncome.metal}`);\n    console.log(`Energy Income:      ${this.padNumber(stats.playerStats.netIncome.energy)}      ${stats.aiStats.netIncome.energy}`);\n    console.log(`Structures:         ${this.padNumber(stats.playerStats.economicStructures)}      ${stats.aiStats.economicStructures}`);\n    \n    // Recent combat log\n    if (gameState.combatLog.length > 0) {\n      console.log('\\nRECENT COMBAT:');\n      const recentCombat = gameState.combatLog.slice(-3); // Last 3 combat events\n      recentCombat.forEach((event, index) => {\n        console.log(`  Turn ${event.turn}: ${event.attacker.toUpperCase()} attacked - ${event.outcome}`);\n      });\n    }\n  }\n\n  /**\n   * Displays help information\n   */\n  public displayHelp(): void {\n    console.log('\\n' + '='.repeat(60));\n    console.log('AVAILABLE COMMANDS');\n    console.log('='.repeat(60));\n    \n    console.log('\\nBUILD COMMANDS:');\n    console.log('  build <quantity> <unit>     - Build units (frigate, cruiser, battleship)');\n    console.log('  build <quantity> <structure> - Build structures (reactor, mine)');\n    console.log('  Examples: \"build 10 frigate\", \"build 1 reactor\"');\n    \n    console.log('\\nATTACK COMMANDS:');\n    console.log('  attack <frigates> <cruisers> <battleships> - Launch attack');\n    console.log('  Example: \"attack 50 20 10\" (sends 50 frigates, 20 cruisers, 10 battleships)');\n    \n    console.log('\\nSCAN COMMANDS:');\n    console.log('  scan basic    - Basic scan (1,000 Energy) - Total fleet count');\n    console.log('  scan deep     - Deep scan (2,500 Energy) - Unit composition + economy');\n    console.log('  scan advanced - Advanced scan (4,000 Energy) - Strategic intent');\n    \n    console.log('\\nGAME COMMANDS:');\n    console.log('  status        - Show detailed game status');\n    console.log('  help          - Show this help message');\n    console.log('  end           - End current turn');\n    console.log('  quit          - Quit the game');\n    \n    console.log('\\nUNIT EFFECTIVENESS (Rock-Paper-Scissors):');\n    console.log('  Frigates > Cruisers > Battleships > Frigates');\n    console.log('  Build time: Frigate (1 turn), Cruiser (2 turns), Battleship (4 turns)');\n    \n    console.log('\\nECONOMIC STRUCTURES:');\n    console.log('  Reactor: +500 Energy/turn (Cost: 900 Metal, 1,200 Energy)');\n    console.log('  Mine: +500 Metal/turn (Cost: 1,500 Metal, 600 Energy)');\n  }\n\n  /**\n   * Displays turn result including combat events with enhanced formatting\n   */\n  public displayTurnResult(turnResult: TurnResult): void {\n    console.log('\\n' + '='.repeat(60));\n    console.log('TURN RESULT');\n    console.log('='.repeat(60));\n    \n    // Display errors first if any\n    if (turnResult.errors.length > 0) {\n      console.log('\\nERRORS:');\n      turnResult.errors.forEach(error => {\n        console.log(`âŒ ${error}`);\n      });\n    }\n    \n    // Display combat events before other turn summary information (Requirement 4.2)\n    if (turnResult.combatEvents && turnResult.combatEvents.length > 0) {\n      console.log('\\nCOMBAT EVENTS:');\n      \n      // Display all combat events that occurred during the turn (Requirement 4.1)\n      turnResult.combatEvents.forEach((event, index) => {\n        try {\n          if (index > 0) {\n            // Add separator between multiple combat events\n            console.log(this.colorManager.createSeparator(60, '='));\n          }\n          \n          // Use enhanced combat display if configured\n          if (this.config.combatDisplay?.useEnhancedFormatting !== false) {\n            this.displayCombatEvent(event);\n          } else {\n            this.displayBasicCombatEvent(event);\n          }\n        } catch (error) {\n          console.log(`\\nâš ï¸  Error displaying combat event ${index + 1}:`);\n          console.log(`   ${error instanceof Error ? error.message : 'Unknown error'}`);\n          console.log('   Skipping to next event...\\n');\n        }\n      });\n    } else {\n      // Display \"No combat this turn\" message (Requirement 4.3)\n      try {\n        const noCombatMessage = this.colorManager.colorize('No combat this turn.', 'neutral');\n        console.log(`\\n${noCombatMessage}`);\n      } catch (error) {\n        console.log('\\nNo combat this turn.');\n      }\n    }\n    \n    // Display other turn summary information after combat events\n    this.displayTurnSummary(turnResult);\n    \n    // Display game over information if applicable\n    if (turnResult.gameEnded) {\n      console.log(`\\nðŸŽ¯ GAME OVER! Winner: ${turnResult.winner?.toUpperCase()}`);\n      console.log(`Victory Type: ${turnResult.victoryType?.toUpperCase()}`);\n    }\n    \n    console.log('\\nPress Enter to continue...');\n  }\n\n  /**\n   * Displays basic combat event information without enhanced formatting\n   */\n  private displayBasicCombatEvent(event: CombatEvent): void {\n    try {\n      // Validate basic event structure\n      if (!event || typeof event !== 'object') {\n        throw new Error('Invalid combat event data');\n      }\n\n      const attackerName = event.attacker === 'player' ? 'YOUR' : 'ENEMY';\n      const defenderName = event.attacker === 'player' ? 'ENEMY' : 'YOUR';\n      \n      console.log(`\\n${attackerName} FLEET ATTACKS ${defenderName} SYSTEM:`);\n      \n      // Basic fleet composition display with error handling\n      const attackerTotal = this.calculateFleetTotal(event.attackerFleet);\n      const defenderTotal = this.calculateFleetTotal(event.defenderFleet);\n      \n      console.log(`  Attacker: ${attackerTotal} ships`);\n      console.log(`  Defender: ${defenderTotal} ships`);\n      \n      // Basic outcome display\n      const outcome = typeof event.outcome === 'string' ? event.outcome : 'unknown';\n      console.log(`  Result: ${this.formatBattleOutcome(outcome)}`);\n      \n      // Basic casualty information with error handling\n      const attackerCasualties = this.calculateFleetTotal(event.casualties?.attacker);\n      const defenderCasualties = this.calculateFleetTotal(event.casualties?.defender);\n      \n      if (attackerCasualties > 0 || defenderCasualties > 0) {\n        console.log(`  Casualties: ${attackerName} lost ${attackerCasualties}, ${defenderName} lost ${defenderCasualties}`);\n      }\n      \n      // Basic survivor information with error handling\n      const attackerSurvivors = this.calculateFleetTotal(event.survivors?.attacker);\n      const defenderSurvivors = this.calculateFleetTotal(event.survivors?.defender);\n      \n      if (attackerSurvivors > 0) {\n        console.log(`  ${attackerName} survivors: ${attackerSurvivors} ships returning home`);\n      }\n      if (defenderSurvivors > 0) {\n        console.log(`  ${defenderName} survivors: ${defenderSurvivors} ships remain in system`);\n      }\n    } catch (error) {\n      console.log('\\nâš ï¸  Error in basic combat display, using fallback:');\n      console.log(`   ${error instanceof Error ? error.message : 'Unknown error'}\\n`);\n      this.displayBasicCombatEventFallback(event);\n    }\n  }\n\n  /**\n   * Displays turn summary information\n   */\n  private displayTurnSummary(turnResult: TurnResult): void {\n    try {\n      // Validate turn result and combat events\n      if (!turnResult || !Array.isArray(turnResult.combatEvents)) {\n        console.log('\\nTurn Summary: No valid combat data available');\n        return;\n      }\n\n      // Display summary of turn events\n      const eventCount = turnResult.combatEvents.length;\n      if (eventCount > 0) {\n        console.log(`\\nTurn Summary: ${eventCount} combat engagement(s) resolved`);\n        \n        // Count victories and defeats with error handling\n        let playerVictories = 0;\n        let playerDefeats = 0;\n        \n        turnResult.combatEvents.forEach((event, index) => {\n          try {\n            if (!event || typeof event !== 'object') {\n              console.warn(`  Warning: Invalid combat event ${index + 1} in summary`);\n              return;\n            }\n\n            const attacker = event.attacker;\n            const outcome = typeof event.outcome === 'string' ? event.outcome : '';\n            \n            const playerWon = (attacker === 'player' && (outcome === 'decisive_attacker' || outcome.includes('attacker'))) ||\n                             (attacker !== 'player' && (outcome === 'decisive_defender' || outcome.includes('defender')));\n            \n            if (playerWon) {\n              playerVictories++;\n            } else if (outcome !== 'close_battle' && outcome !== '') {\n              playerDefeats++;\n            }\n          } catch (error) {\n            console.warn(`  Warning: Error processing combat event ${index + 1} in summary:`, error instanceof Error ? error.message : 'Unknown error');\n          }\n        });\n        \n        // Display victory/defeat counts with error handling\n        try {\n          if (playerVictories > 0) {\n            console.log(`  Player victories: ${this.colorManager.colorize(playerVictories.toString(), 'victory')}`);\n          }\n          if (playerDefeats > 0) {\n            console.log(`  Player defeats: ${this.colorManager.colorize(playerDefeats.toString(), 'defeat')}`);\n          }\n          \n          const closeBattles = eventCount - playerVictories - playerDefeats;\n          if (closeBattles > 0) {\n            console.log(`  Close battles: ${this.colorManager.colorize(closeBattles.toString(), 'neutral')}`);\n          }\n        } catch (error) {\n          console.log(`  Player victories: ${playerVictories}`);\n          console.log(`  Player defeats: ${playerDefeats}`);\n          console.log(`  Close battles: ${eventCount - playerVictories - playerDefeats}`);\n        }\n      }\n    } catch (error) {\n      console.log('\\nTurn Summary: Error generating summary -', error instanceof Error ? error.message : 'Unknown error');\n    }\n  }\n\n  /**\n   * Validates combat event data before display\n   */\n  private validateCombatEvent(event: CombatEvent): { isValid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    // Validate basic event structure\n    if (!event || typeof event !== 'object') {\n      errors.push('Combat event is null or not an object');\n      return { isValid: false, errors };\n    }\n\n    // Validate required fields\n    if (typeof event.turn !== 'number' || event.turn < 1) {\n      errors.push('Invalid turn number');\n    }\n\n    if (event.attacker !== 'player' && event.attacker !== 'ai') {\n      errors.push('Invalid attacker type');\n    }\n\n    if (!event.outcome || typeof event.outcome !== 'string') {\n      errors.push('Missing or invalid battle outcome');\n    }\n\n    // Validate fleet compositions\n    const attackerFleetValidation = this.validateFleetComposition(event.attackerFleet, 'attacker fleet');\n    const defenderFleetValidation = this.validateFleetComposition(event.defenderFleet, 'defender fleet');\n    \n    errors.push(...attackerFleetValidation.errors);\n    errors.push(...defenderFleetValidation.errors);\n\n    // Validate casualties\n    const attackerCasualtiesValidation = this.validateFleetComposition(event.casualties?.attacker, 'attacker casualties');\n    const defenderCasualtiesValidation = this.validateFleetComposition(event.casualties?.defender, 'defender casualties');\n    \n    errors.push(...attackerCasualtiesValidation.errors);\n    errors.push(...defenderCasualtiesValidation.errors);\n\n    // Validate survivors\n    const attackerSurvivorsValidation = this.validateFleetComposition(event.survivors?.attacker, 'attacker survivors');\n    const defenderSurvivorsValidation = this.validateFleetComposition(event.survivors?.defender, 'defender survivors');\n    \n    errors.push(...attackerSurvivorsValidation.errors);\n    errors.push(...defenderSurvivorsValidation.errors);\n\n    // Validate mathematical consistency (original = casualties + survivors)\n    if (errors.length === 0) {\n      const attackerOriginalTotal = (event.attackerFleet?.frigates || 0) + (event.attackerFleet?.cruisers || 0) + (event.attackerFleet?.battleships || 0);\n      const attackerCasualtiesTotal = (event.casualties?.attacker?.frigates || 0) + (event.casualties?.attacker?.cruisers || 0) + (event.casualties?.attacker?.battleships || 0);\n      const attackerSurvivorsTotal = (event.survivors?.attacker?.frigates || 0) + (event.survivors?.attacker?.cruisers || 0) + (event.survivors?.attacker?.battleships || 0);\n      \n      if (attackerOriginalTotal !== attackerCasualtiesTotal + attackerSurvivorsTotal) {\n        errors.push(`Attacker fleet math inconsistency: ${attackerOriginalTotal} original â‰  ${attackerCasualtiesTotal} casualties + ${attackerSurvivorsTotal} survivors`);\n      }\n\n      const defenderOriginalTotal = (event.defenderFleet?.frigates || 0) + (event.defenderFleet?.cruisers || 0) + (event.defenderFleet?.battleships || 0);\n      const defenderCasualtiesTotal = (event.casualties?.defender?.frigates || 0) + (event.casualties?.defender?.cruisers || 0) + (event.casualties?.defender?.battleships || 0);\n      const defenderSurvivorsTotal = (event.survivors?.defender?.frigates || 0) + (event.survivors?.defender?.cruisers || 0) + (event.survivors?.defender?.battleships || 0);\n      \n      if (defenderOriginalTotal !== defenderCasualtiesTotal + defenderSurvivorsTotal) {\n        errors.push(`Defender fleet math inconsistency: ${defenderOriginalTotal} original â‰  ${defenderCasualtiesTotal} casualties + ${defenderSurvivorsTotal} survivors`);\n      }\n    }\n\n    return { isValid: errors.length === 0, errors };\n  }\n\n  /**\n   * Validates fleet composition data\n   */\n  private validateFleetComposition(fleet: FleetComposition | undefined, context: string): { isValid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    if (!fleet) {\n      errors.push(`Missing ${context} data`);\n      return { isValid: false, errors };\n    }\n\n    if (typeof fleet !== 'object') {\n      errors.push(`Invalid ${context} data type`);\n      return { isValid: false, errors };\n    }\n\n    // Validate individual ship counts\n    const shipTypes = ['frigates', 'cruisers', 'battleships'] as const;\n    \n    for (const shipType of shipTypes) {\n      const count = fleet[shipType];\n      if (typeof count !== 'number' || isNaN(count) || !isFinite(count) || count < 0) {\n        errors.push(`Invalid ${shipType} count in ${context}: ${count}`);\n      }\n    }\n\n    return { isValid: errors.length === 0, errors };\n  }\n\n  /**\n   * Creates a safe fallback combat event for display when validation fails\n   */\n  private createFallbackCombatEvent(originalEvent: any): CombatEvent {\n    return {\n      turn: typeof originalEvent?.turn === 'number' ? originalEvent.turn : 0,\n      attacker: originalEvent?.attacker === 'player' || originalEvent?.attacker === 'ai' ? originalEvent.attacker : 'ai',\n      attackerFleet: this.createSafeFleetComposition(originalEvent?.attackerFleet),\n      defenderFleet: this.createSafeFleetComposition(originalEvent?.defenderFleet),\n      outcome: typeof originalEvent?.outcome === 'string' ? originalEvent.outcome : 'unknown_outcome',\n      casualties: {\n        attacker: this.createSafeFleetComposition(originalEvent?.casualties?.attacker),\n        defender: this.createSafeFleetComposition(originalEvent?.casualties?.defender)\n      },\n      survivors: {\n        attacker: this.createSafeFleetComposition(originalEvent?.survivors?.attacker),\n        defender: this.createSafeFleetComposition(originalEvent?.survivors?.defender)\n      }\n    };\n  }\n\n  /**\n   * Creates a safe fleet composition with validated values\n   */\n  private createSafeFleetComposition(fleet: any): FleetComposition {\n    return {\n      frigates: this.validateShipCount(fleet?.frigates),\n      cruisers: this.validateShipCount(fleet?.cruisers),\n      battleships: this.validateShipCount(fleet?.battleships)\n    };\n  }\n\n  /**\n   * Validates and sanitizes ship count values\n   */\n  private validateShipCount(count: any): number {\n    if (typeof count === 'number' && isFinite(count) && count >= 0) {\n      return Math.floor(count);\n    }\n    return 0;\n  }\n\n  /**\n   * Displays a single combat event with enhanced formatting and tactical analysis\n   */\n  private displayCombatEvent(event: CombatEvent): void {\n    // Validate combat event data before display\n    const validation = this.validateCombatEvent(event);\n    \n    if (!validation.isValid) {\n      console.log('\\nâš ï¸  Combat Event Display Error:');\n      validation.errors.forEach(error => {\n        console.log(`   ${error}`);\n      });\n      \n      // Attempt to display with fallback data\n      console.log('   Attempting to display with corrected data...\\n');\n      \n      try {\n        const fallbackEvent = this.createFallbackCombatEvent(event);\n        const fallbackValidation = this.validateCombatEvent(fallbackEvent);\n        \n        if (fallbackValidation.isValid) {\n          event = fallbackEvent;\n        } else {\n          console.log('   Unable to create valid fallback data. Displaying basic combat summary.\\n');\n          this.displayBasicCombatEventFallback(event);\n          return;\n        }\n      } catch (error) {\n        console.log('   Critical error in combat display. Skipping event.\\n');\n        console.log(`   Error: ${error instanceof Error ? error.message : 'Unknown error'}\\n`);\n        return;\n      }\n    }\n\n    try {\n      const attackerName = event.attacker === 'player' ? 'YOUR' : 'ENEMY';\n      const defenderName = event.attacker === 'player' ? 'ENEMY' : 'YOUR';\n      const attackerType = event.attacker === 'player' ? 'player' : 'ai';\n      const defenderType = event.attacker === 'player' ? 'ai' : 'player';\n      \n      // Create enhanced combat display with tactical analysis\n      const enhancedDisplay = this.tacticalAnalyzer.createEnhancedCombatDisplay(event);\n    \n    // Display battle header with colors\n    const attackerHeader = this.colorManager.formatPlayerIdentifier(attackerType, attackerName);\n    const defenderHeader = this.colorManager.formatPlayerIdentifier(defenderType, defenderName);\n    console.log(`\\n${attackerHeader} FLEET ATTACKS ${defenderHeader} SYSTEM:`);\n    \n    // Display detailed fleet compositions with color coding\n    this.displayDetailedFleetComposition('Attacker', event.attackerFleet, attackerType);\n    this.displayDetailedFleetComposition('Defender', event.defenderFleet, defenderType);\n    \n    // Display tactical analysis if configured and available\n    if (this.config.combatDisplay?.showTacticalAnalysis !== false && enhancedDisplay.tacticalAdvantages.length > 0) {\n      console.log('\\n  Tactical Analysis:');\n      enhancedDisplay.tacticalAdvantages.forEach(advantage => {\n        const advantageColor = advantage.advantage === 'strong' ? 'victory' : \n                              advantage.advantage === 'weak' ? 'defeat' : 'neutral';\n        const advantageText = this.colorManager.colorize(\n          `${advantage.advantage.toUpperCase()}`, \n          advantageColor\n        );\n        console.log(`    ${advantage.unitType.charAt(0).toUpperCase() + advantage.unitType.slice(1)}s: ${advantageText} (${advantage.effectivenessRatio.toFixed(1)}x effectiveness)`);\n      });\n    }\n\n    // Display battle phase progression if configured and available\n    if (this.config.combatDisplay?.showBattlePhases !== false && enhancedDisplay.battlePhases.length > 0) {\n      console.log('\\n  Battle Progression:');\n      enhancedDisplay.battlePhases.forEach((phase, index) => {\n        this.displayBattlePhase(phase, index + 1);\n      });\n    }\n    \n    // Display battle outcome with enhanced formatting\n    const perspective = event.attacker === 'player' ? 'attacker' : 'defender';\n    const outcomeText = this.colorManager.formatBattleOutcome(event.outcome, perspective);\n    console.log(`\\n  Battle Result: ${outcomeText}`);\n    \n    // Add battle explanation based on outcome\n    this.displayBattleExplanation(event.outcome, enhancedDisplay.effectivenessRatios);\n    \n    // Display casualty information (enhanced or basic based on configuration)\n    if (this.config.combatDisplay?.detailedCasualties !== false) {\n      this.displayEnhancedCasualties(event, enhancedDisplay.casualtyPercentages, attackerName, defenderName);\n    } else {\n      this.displayBasicCasualties(event, attackerName, defenderName);\n    }\n    \n    // Display survivors with enhanced formatting\n    this.displayEnhancedSurvivors(event, attackerName, defenderName, attackerType, defenderType);\n    \n      // Add visual separator\n      console.log(this.colorManager.createSeparator(50, 'Â·'));\n    } catch (error) {\n      console.log('âš ï¸  Error during enhanced combat display, falling back to basic display:');\n      console.log(`   ${error instanceof Error ? error.message : 'Unknown error'}\\n`);\n      \n      try {\n        this.displayBasicCombatEvent(event);\n      } catch (fallbackError) {\n        console.log('âš ï¸  Critical error in combat display fallback:');\n        console.log(`   ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}\\n`);\n        this.displayBasicCombatEventFallback(event);\n      }\n    }\n  }\n\n  /**\n   * Displays minimal combat information when all other display methods fail\n   */\n  private displayBasicCombatEventFallback(event: any): void {\n    try {\n      console.log('\\n--- COMBAT EVENT (BASIC DISPLAY) ---');\n      \n      const turn = typeof event?.turn === 'number' ? event.turn : 'Unknown';\n      const attacker = event?.attacker === 'player' ? 'Player' : \n                     event?.attacker === 'ai' ? 'AI' : 'Unknown';\n      const outcome = typeof event?.outcome === 'string' ? event.outcome : 'Unknown';\n      \n      console.log(`Turn: ${turn}`);\n      console.log(`Attacker: ${attacker}`);\n      console.log(`Outcome: ${outcome}`);\n      \n      // Try to display basic fleet information if available\n      if (event?.attackerFleet) {\n        const attackerTotal = this.calculateFleetTotal(event.attackerFleet);\n        console.log(`Attacker Fleet: ${attackerTotal} ships`);\n      }\n      \n      if (event?.defenderFleet) {\n        const defenderTotal = this.calculateFleetTotal(event.defenderFleet);\n        console.log(`Defender Fleet: ${defenderTotal} ships`);\n      }\n      \n      console.log('--- END COMBAT EVENT ---\\n');\n    } catch (error) {\n      console.log('\\n--- COMBAT EVENT DATA CORRUPTED ---');\n      console.log('Unable to display combat information due to data corruption.');\n      console.log('--- END COMBAT EVENT ---\\n');\n    }\n  }\n\n  /**\n   * Safely calculates total fleet size with error handling\n   */\n  private calculateFleetTotal(fleet: any): number {\n    try {\n      if (!fleet || typeof fleet !== 'object') {\n        return 0;\n      }\n      \n      const frigates = typeof fleet.frigates === 'number' && isFinite(fleet.frigates) ? Math.max(0, fleet.frigates) : 0;\n      const cruisers = typeof fleet.cruisers === 'number' && isFinite(fleet.cruisers) ? Math.max(0, fleet.cruisers) : 0;\n      const battleships = typeof fleet.battleships === 'number' && isFinite(fleet.battleships) ? Math.max(0, fleet.battleships) : 0;\n      \n      return Math.floor(frigates + cruisers + battleships);\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  /**\n   * Safely formats battle outcome with error handling\n   */\n  private formatBattleOutcome(outcome: string): string {\n    try {\n      if (typeof outcome !== 'string') {\n        return 'UNKNOWN OUTCOME';\n      }\n      return outcome.toUpperCase().replace(/_/g, ' ');\n    } catch (error) {\n      return 'UNKNOWN OUTCOME';\n    }\n  }\n\n  /**\n   * Displays detailed fleet composition with color coding\n   */\n  private displayDetailedFleetComposition(\n    label: string, \n    fleet: FleetComposition, \n    playerType: 'player' | 'ai'\n  ): void {\n    const total = fleet.frigates + fleet.cruisers + fleet.battleships;\n    const coloredLabel = this.colorManager.formatPlayerIdentifier(playerType, label);\n    const coloredComposition = this.colorManager.formatFleetComposition(fleet);\n    \n    console.log(`  ${coloredLabel}: ${total} ships (${coloredComposition})`);\n  }\n\n  /**\n   * Displays a single battle phase with appropriate formatting and colors\n   */\n  private displayBattlePhase(phase: import('./TacticalAnalyzer.js').BattlePhase, phaseNumber: number): void {\n    // Create phase header with visual separator\n    const phaseHeader = `Phase ${phaseNumber}: ${phase.phase.charAt(0).toUpperCase() + phase.phase.slice(1)}`;\n    const phaseSeparator = this.colorManager.createSeparator(30, 'Â·');\n    \n    console.log(`    ${phaseSeparator}`);\n    console.log(`    ${this.colorManager.colorize(phaseHeader, 'neutral')}`);\n    \n    // Display phase description\n    console.log(`    ${phase.description}`);\n    \n    // Display phase advantage with appropriate coloring\n    const advantageText = this.formatPhaseAdvantage(phase.advantage);\n    console.log(`    Advantage: ${advantageText}`);\n    \n    // Display strength ratio if meaningful\n    if (phase.strengthRatio !== Infinity && phase.strengthRatio > 0) {\n      const ratioText = this.formatStrengthRatio(phase.strengthRatio);\n      console.log(`    Force Ratio: ${ratioText}`);\n    }\n  }\n\n  /**\n   * Formats phase advantage with appropriate colors\n   */\n  private formatPhaseAdvantage(advantage: 'attacker' | 'defender' | 'neutral'): string {\n    let colorType: keyof import('./ColorManager.js').ColorTheme;\n    let displayText: string;\n    \n    switch (advantage) {\n      case 'attacker':\n        colorType = 'player'; // Use player color for attacker advantage\n        displayText = 'ATTACKER';\n        break;\n      case 'defender':\n        colorType = 'enemy'; // Use enemy color for defender advantage\n        displayText = 'DEFENDER';\n        break;\n      case 'neutral':\n        colorType = 'neutral';\n        displayText = 'BALANCED';\n        break;\n    }\n    \n    return this.colorManager.colorize(displayText, colorType);\n  }\n\n  /**\n   * Formats strength ratio with contextual information\n   */\n  private formatStrengthRatio(ratio: number): string {\n    let ratioText: string;\n    let colorType: keyof import('./ColorManager.js').ColorTheme;\n    \n    if (ratio >= 2.0) {\n      ratioText = `${ratio.toFixed(1)}:1 (Overwhelming Attacker)`;\n      colorType = 'victory';\n    } else if (ratio >= 1.5) {\n      ratioText = `${ratio.toFixed(1)}:1 (Strong Attacker)`;\n      colorType = 'victory';\n    } else if (ratio >= 1.2) {\n      ratioText = `${ratio.toFixed(1)}:1 (Slight Attacker)`;\n      colorType = 'neutral';\n    } else if (ratio >= 0.8) {\n      ratioText = `${ratio.toFixed(1)}:1 (Balanced)`;\n      colorType = 'neutral';\n    } else if (ratio >= 0.5) {\n      ratioText = `${ratio.toFixed(1)}:1 (Slight Defender)`;\n      colorType = 'neutral';\n    } else {\n      ratioText = `${ratio.toFixed(1)}:1 (Strong Defender)`;\n      colorType = 'defeat';\n    }\n    \n    return this.colorManager.colorize(ratioText, colorType);\n  }\n\n  /**\n   * Displays battle explanation based on outcome and effectiveness ratios\n   */\n  private displayBattleExplanation(\n    outcome: string, \n    effectivenessRatios: { attackerEffectiveness: number; defenderEffectiveness: number }\n  ): void {\n    let explanation: string;\n    \n    switch (outcome) {\n      case 'decisive_attacker':\n        if (effectivenessRatios.attackerEffectiveness > 1.5) {\n          explanation = 'Attacker achieved overwhelming tactical superiority';\n        } else {\n          explanation = 'Attacker overwhelmed defender through superior numbers';\n        }\n        break;\n      case 'decisive_defender':\n        if (effectivenessRatios.defenderEffectiveness > 1.5) {\n          explanation = 'Defender exploited tactical advantages for decisive victory';\n        } else {\n          explanation = 'Defender successfully repelled attack with superior positioning';\n        }\n        break;\n      case 'close_battle':\n        explanation = 'Evenly matched forces resulted in heavy casualties on both sides';\n        break;\n      default:\n        explanation = 'Battle concluded with significant losses';\n    }\n    \n    console.log(`    ${explanation}`);\n  }\n\n  /**\n   * Displays basic casualty information without detailed analysis\n   */\n  private displayBasicCasualties(\n    event: CombatEvent,\n    attackerName: string,\n    defenderName: string\n  ): void {\n    const attackerCasualties = event.casualties.attacker.frigates + event.casualties.attacker.cruisers + event.casualties.attacker.battleships;\n    const defenderCasualties = event.casualties.defender.frigates + event.casualties.defender.cruisers + event.casualties.defender.battleships;\n    \n    if (attackerCasualties > 0 || defenderCasualties > 0) {\n      console.log('\\n  Casualties:');\n      if (attackerCasualties > 0) {\n        console.log(`    ${attackerName}: ${attackerCasualties} ships lost`);\n      }\n      if (defenderCasualties > 0) {\n        console.log(`    ${defenderName}: ${defenderCasualties} ships lost`);\n      }\n    }\n  }\n\n  /**\n   * Displays enhanced casualty information with percentages and color coding\n   */\n  private displayEnhancedCasualties(\n    event: CombatEvent,\n    casualtyPercentages: { attackerLossRate: number; defenderLossRate: number },\n    attackerName: string,\n    defenderName: string\n  ): void {\n    const attackerTotal = event.attackerFleet.frigates + event.attackerFleet.cruisers + event.attackerFleet.battleships;\n    const defenderTotal = event.defenderFleet.frigates + event.defenderFleet.cruisers + event.defenderFleet.battleships;\n    \n    const attackerCasualties = event.casualties.attacker.frigates + event.casualties.attacker.cruisers + event.casualties.attacker.battleships;\n    const defenderCasualties = event.casualties.defender.frigates + event.casualties.defender.cruisers + event.casualties.defender.battleships;\n    \n    console.log('\\n  Casualties:');\n    \n    // Attacker casualties with enhanced percentage display\n    const attackerPercentage = Math.round(casualtyPercentages.attackerLossRate * 100);\n    const attackerCasualtyText = this.colorManager.formatCasualties(attackerCasualties, attackerTotal);\n    const attackerSeverity = this.getCasualtySeverity(casualtyPercentages.attackerLossRate);\n    const attackerSeverityText = this.colorManager.colorize(`[${attackerSeverity}]`, this.getCasualtySeverityColor(casualtyPercentages.attackerLossRate));\n    console.log(`    ${attackerName}: ${attackerCasualtyText} ${attackerSeverityText}`);\n    \n    // Defender casualties with enhanced percentage display\n    const defenderPercentage = Math.round(casualtyPercentages.defenderLossRate * 100);\n    const defenderCasualtyText = this.colorManager.formatCasualties(defenderCasualties, defenderTotal);\n    const defenderSeverity = this.getCasualtySeverity(casualtyPercentages.defenderLossRate);\n    const defenderSeverityText = this.colorManager.colorize(`[${defenderSeverity}]`, this.getCasualtySeverityColor(casualtyPercentages.defenderLossRate));\n    console.log(`    ${defenderName}: ${defenderCasualtyText} ${defenderSeverityText}`);\n    \n    // Show detailed breakdown with tactical context\n    if (attackerCasualties > 0) {\n      const attackerBreakdown = this.formatCasualtyBreakdown(event.casualties.attacker);\n      if (attackerBreakdown) {\n        console.log(`      Breakdown: ${attackerBreakdown}`);\n        \n        // Add tactical context for heavy losses\n        if (casualtyPercentages.attackerLossRate > 0.6) {\n          const tacticalContext = this.getCasualtyTacticalContext(event.casualties.attacker, event.attackerFleet);\n          if (tacticalContext) {\n            console.log(`      ${this.colorManager.colorize('Impact:', 'neutral')} ${tacticalContext}`);\n          }\n        }\n      }\n    }\n    \n    if (defenderCasualties > 0) {\n      const defenderBreakdown = this.formatCasualtyBreakdown(event.casualties.defender);\n      if (defenderBreakdown) {\n        console.log(`      Breakdown: ${defenderBreakdown}`);\n        \n        // Add tactical context for heavy losses\n        if (casualtyPercentages.defenderLossRate > 0.6) {\n          const tacticalContext = this.getCasualtyTacticalContext(event.casualties.defender, event.defenderFleet);\n          if (tacticalContext) {\n            console.log(`      ${this.colorManager.colorize('Impact:', 'neutral')} ${tacticalContext}`);\n          }\n        }\n      }\n    }\n    \n    // Show comparative loss analysis\n    if (attackerCasualties > 0 || defenderCasualties > 0) {\n      this.displayComparativeLossAnalysis(casualtyPercentages, attackerName, defenderName);\n    }\n  }\n\n  /**\n   * Displays enhanced survivor information with tactical context and color coding\n   */\n  private displayEnhancedSurvivors(\n    event: CombatEvent,\n    attackerName: string,\n    defenderName: string,\n    attackerType: 'player' | 'ai',\n    defenderType: 'player' | 'ai'\n  ): void {\n    const attackerSurvivors = event.survivors.attacker.frigates + event.survivors.attacker.cruisers + event.survivors.attacker.battleships;\n    const defenderSurvivors = event.survivors.defender.frigates + event.survivors.defender.cruisers + event.survivors.defender.battleships;\n    const attackerOriginal = event.attackerFleet.frigates + event.attackerFleet.cruisers + event.attackerFleet.battleships;\n    const defenderOriginal = event.defenderFleet.frigates + event.defenderFleet.cruisers + event.defenderFleet.battleships;\n    \n    if (attackerSurvivors > 0 || defenderSurvivors > 0) {\n      console.log('\\n  Survivors:');\n      \n      if (attackerSurvivors > 0) {\n        const survivorText = this.colorManager.formatSurvivors(attackerSurvivors);\n        const playerLabel = this.colorManager.formatPlayerIdentifier(attackerType, attackerName);\n        const survivalRate = Math.round((attackerSurvivors / attackerOriginal) * 100);\n        const survivalRateText = this.colorManager.colorize(`${survivalRate}% survival`, this.getSurvivalRateColor(survivalRate));\n        \n        console.log(`    ${playerLabel}: ${survivorText} returning home (${survivalRateText})`);\n        \n        const survivorComposition = this.colorManager.formatFleetComposition(event.survivors.attacker);\n        console.log(`      Composition: ${survivorComposition}`);\n        \n        // Add tactical context for survivors\n        const tacticalContext = this.getSurvivorTacticalContext(event.survivors.attacker, event.attackerFleet, 'attacker');\n        if (tacticalContext) {\n          console.log(`      ${this.colorManager.colorize('Status:', 'neutral')} ${tacticalContext}`);\n        }\n        \n        // Add return journey information\n        console.log(`      ${this.colorManager.colorize('Return ETA:', 'neutral')} Next turn`);\n      }\n      \n      if (defenderSurvivors > 0) {\n        const survivorText = this.colorManager.formatSurvivors(defenderSurvivors);\n        const playerLabel = this.colorManager.formatPlayerIdentifier(defenderType, defenderName);\n        const survivalRate = Math.round((defenderSurvivors / defenderOriginal) * 100);\n        const survivalRateText = this.colorManager.colorize(`${survivalRate}% survival`, this.getSurvivalRateColor(survivalRate));\n        \n        console.log(`    ${playerLabel}: ${survivorText} remain in system (${survivalRateText})`);\n        \n        const survivorComposition = this.colorManager.formatFleetComposition(event.survivors.defender);\n        console.log(`      Composition: ${survivorComposition}`);\n        \n        // Add tactical context for survivors\n        const tacticalContext = this.getSurvivorTacticalContext(event.survivors.defender, event.defenderFleet, 'defender');\n        if (tacticalContext) {\n          console.log(`      ${this.colorManager.colorize('Status:', 'neutral')} ${tacticalContext}`);\n        }\n        \n        // Add defensive capability assessment\n        const defensiveStrength = this.assessDefensiveStrength(event.survivors.defender);\n        if (defensiveStrength) {\n          console.log(`      ${this.colorManager.colorize('Defense:', 'neutral')} ${defensiveStrength}`);\n        }\n      }\n    } else {\n      const totalAnnihilationText = this.colorManager.colorize('Total fleet annihilation - no survivors', 'casualties');\n      console.log(`\\n  ${totalAnnihilationText}`);\n      \n      // Add tactical implications of total loss\n      if (event.outcome === 'decisive_attacker' || event.outcome === 'decisive_defender') {\n        console.log(`    ${this.colorManager.colorize('Impact:', 'neutral')} Complete tactical dominance achieved`);\n      } else {\n        console.log(`    ${this.colorManager.colorize('Impact:', 'neutral')} Mutual destruction in fierce engagement`);\n      }\n    }\n  }\n\n  /**\n   * Formats casualty breakdown by unit type\n   */\n  private formatCasualtyBreakdown(casualties: FleetComposition): string {\n    const parts: string[] = [];\n    \n    if (casualties.frigates > 0) {\n      parts.push(this.colorManager.colorize(`${casualties.frigates}F`, 'frigate'));\n    }\n    if (casualties.cruisers > 0) {\n      parts.push(this.colorManager.colorize(`${casualties.cruisers}C`, 'cruiser'));\n    }\n    if (casualties.battleships > 0) {\n      parts.push(this.colorManager.colorize(`${casualties.battleships}B`, 'battleship'));\n    }\n    \n    return parts.join(', ');\n  }\n\n  /**\n   * Gets casualty severity description based on loss rate\n   */\n  private getCasualtySeverity(lossRate: number): string {\n    if (lossRate >= 0.8) return 'DEVASTATING';\n    if (lossRate >= 0.6) return 'HEAVY';\n    if (lossRate >= 0.4) return 'MODERATE';\n    if (lossRate >= 0.2) return 'LIGHT';\n    if (lossRate > 0) return 'MINIMAL';\n    return 'NONE';\n  }\n\n  /**\n   * Gets color for casualty severity\n   */\n  private getCasualtySeverityColor(lossRate: number): keyof import('./ColorManager.js').ColorTheme {\n    if (lossRate >= 0.6) return 'casualties';\n    if (lossRate >= 0.4) return 'defeat';\n    if (lossRate >= 0.2) return 'neutral';\n    return 'victory';\n  }\n\n  /**\n   * Gets tactical context for casualties based on unit types lost\n   */\n  private getCasualtyTacticalContext(casualties: FleetComposition, originalFleet: FleetComposition): string | null {\n    const totalCasualties = casualties.frigates + casualties.cruisers + casualties.battleships;\n    const totalOriginal = originalFleet.frigates + originalFleet.cruisers + originalFleet.battleships;\n    \n    if (totalCasualties === 0 || totalOriginal === 0) return null;\n    \n    // Analyze which unit types suffered the most\n    const frigateRate = originalFleet.frigates > 0 ? casualties.frigates / originalFleet.frigates : 0;\n    const cruiserRate = originalFleet.cruisers > 0 ? casualties.cruisers / originalFleet.cruisers : 0;\n    const battleshipRate = originalFleet.battleships > 0 ? casualties.battleships / originalFleet.battleships : 0;\n    \n    const maxRate = Math.max(frigateRate, cruiserRate, battleshipRate);\n    \n    if (maxRate === frigateRate && frigateRate > 0.7) {\n      return 'Frigate screen decimated, vulnerable to cruiser attacks';\n    } else if (maxRate === cruiserRate && cruiserRate > 0.7) {\n      return 'Cruiser force crippled, reduced anti-battleship capability';\n    } else if (maxRate === battleshipRate && battleshipRate > 0.7) {\n      return 'Heavy units eliminated, lost primary striking power';\n    } else if (totalCasualties / totalOriginal > 0.8) {\n      return 'Fleet combat effectiveness severely compromised';\n    }\n    \n    return null;\n  }\n\n  /**\n   * Displays comparative loss analysis between attacker and defender\n   */\n  private displayComparativeLossAnalysis(\n    casualtyPercentages: { attackerLossRate: number; defenderLossRate: number },\n    attackerName: string,\n    defenderName: string\n  ): void {\n    const attackerRate = casualtyPercentages.attackerLossRate;\n    const defenderRate = casualtyPercentages.defenderLossRate;\n    \n    if (Math.abs(attackerRate - defenderRate) < 0.1) {\n      console.log(`    ${this.colorManager.colorize('Analysis:', 'neutral')} Evenly matched losses - pyrrhic engagement`);\n    } else if (attackerRate > defenderRate * 1.5) {\n      const advantage = Math.round((attackerRate / defenderRate) * 100);\n      console.log(`    ${this.colorManager.colorize('Analysis:', 'neutral')} ${defenderName} achieved ${advantage}% better casualty ratio`);\n    } else if (defenderRate > attackerRate * 1.5) {\n      const advantage = Math.round((defenderRate / attackerRate) * 100);\n      console.log(`    ${this.colorManager.colorize('Analysis:', 'neutral')} ${attackerName} achieved ${advantage}% better casualty ratio`);\n    }\n  }\n\n  /**\n   * Gets color for survival rate display\n   */\n  private getSurvivalRateColor(survivalRate: number): keyof import('./ColorManager.js').ColorTheme {\n    if (survivalRate >= 70) return 'victory';\n    if (survivalRate >= 50) return 'neutral';\n    if (survivalRate >= 30) return 'defeat';\n    return 'casualties';\n  }\n\n  /**\n   * Gets tactical context for survivors\n   */\n  private getSurvivorTacticalContext(\n    survivors: FleetComposition, \n    originalFleet: FleetComposition, \n    role: 'attacker' | 'defender'\n  ): string | null {\n    const totalSurvivors = survivors.frigates + survivors.cruisers + survivors.battleships;\n    const totalOriginal = originalFleet.frigates + originalFleet.cruisers + originalFleet.battleships;\n    \n    if (totalSurvivors === 0 || totalOriginal === 0) return null;\n    \n    const survivalRate = totalSurvivors / totalOriginal;\n    \n    // Analyze fleet composition balance of survivors\n    const frigateRatio = totalSurvivors > 0 ? survivors.frigates / totalSurvivors : 0;\n    const cruiserRatio = totalSurvivors > 0 ? survivors.cruisers / totalSurvivors : 0;\n    const battleshipRatio = totalSurvivors > 0 ? survivors.battleships / totalSurvivors : 0;\n    \n    if (survivalRate > 0.8) {\n      return role === 'attacker' ? 'Overwhelming victory, minimal losses' : 'Successfully repelled attack';\n    } else if (survivalRate > 0.6) {\n      return role === 'attacker' ? 'Successful assault with acceptable losses' : 'Defended with moderate casualties';\n    } else if (survivalRate > 0.4) {\n      return 'Bloodied but combat effective';\n    } else if (survivalRate > 0.2) {\n      if (frigateRatio > 0.7) {\n        return 'Mostly light units survived, limited striking power';\n      } else if (battleshipRatio > 0.5) {\n        return 'Heavy units intact but lacking escort';\n      } else {\n        return 'Severely weakened, requires reinforcement';\n      }\n    } else {\n      return 'Barely escaped annihilation';\n    }\n  }\n\n  /**\n   * Assesses defensive strength of surviving fleet\n   */\n  private assessDefensiveStrength(survivors: FleetComposition): string | null {\n    const total = survivors.frigates + survivors.cruisers + survivors.battleships;\n    \n    if (total === 0) return null;\n    \n    if (total >= 50) {\n      return 'Strong defensive capability maintained';\n    } else if (total >= 20) {\n      return 'Moderate defensive capability';\n    } else if (total >= 10) {\n      return 'Limited defensive capability';\n    } else {\n      return 'Minimal defensive capability - vulnerable to follow-up attacks';\n    }\n  }\n\n  /**\n   * Displays game over screen\n   */\n  public displayGameOver(gameState: GameState): void {\n    console.log('\\n' + '='.repeat(60));\n    console.log('GAME OVER');\n    console.log('='.repeat(60));\n    \n    const winner = gameState.winner;\n    const victoryType = gameState.victoryType;\n    \n    if (winner === 'player') {\n      console.log('ðŸŽ‰ VICTORY! You have defeated the AI!');\n    } else {\n      console.log('ðŸ’€ DEFEAT! The AI has defeated you!');\n    }\n    \n    console.log(`\\nVictory Type: ${victoryType?.toUpperCase()}`);\n    console.log(`Game Length: ${gameState.turn} turns`);\n    console.log(`Final Phase: ${gameState.gamePhase}`);\n    \n    if (victoryType === 'military') {\n      console.log('\\nThe enemy fleet has been completely eliminated!');\n    } else if (victoryType === 'economic') {\n      console.log('\\nThe enemy economy has collapsed!');\n    }\n    \n    console.log('\\nType \"quit\" to exit or start a new game.');\n  }\n\n  /**\n   * Displays error messages\n   */\n  public displayError(message: string): void {\n    console.log(`âŒ Error: ${message}`);\n  }\n\n  /**\n   * Helper methods for formatting\n   */\n  private formatNumber(num: number): string {\n    return num.toLocaleString();\n  }\n\n  private formatIncome(income: number): string {\n    const sign = income >= 0 ? '+' : '';\n    return `${sign}${this.formatNumber(income)}`;\n  }\n\n  private padNumber(num: number, width: number = 8): string {\n    return num.toString().padStart(width);\n  }\n\n  private getFleetMovementStatus(movement: any): string {\n    // This would need to be implemented based on the actual FleetMovement interface\n    return `${movement.missionType} (arrives turn ${movement.arrivalTurn})`;\n  }\n\n  private getConstructionProgress(order: any): string {\n    const remaining = order.turnsRemaining;\n    if (remaining === 1) {\n      return 'Completes next turn';\n    } else {\n      return `${remaining} turns remaining`;\n    }\n  }\n\n\n}","import { GameState, FleetComposition } from '../models/GameState.js';\nimport { BuildableType, UnitType, StructureType } from '../models/PlayerState.js';\nimport { ScanType, SCAN_COSTS } from '../models/Intelligence.js';\n\nexport interface Command {\n  type: 'build' | 'attack' | 'scan' | 'status' | 'help' | 'end_turn' | 'quit';\n  buildType?: BuildableType;\n  quantity?: number;\n  attackFleet?: FleetComposition;\n  target?: string;\n  scanType?: ScanType;\n}\n\nexport interface CommandResult {\n  success: boolean;\n  command?: Command;\n  error?: string;\n}\n\nexport class InputHandler {\n  private readonly UNIT_TYPES: UnitType[] = ['frigate', 'cruiser', 'battleship'];\n  private readonly STRUCTURE_TYPES: StructureType[] = ['reactor', 'mine'];\n  private readonly SCAN_TYPES: ScanType[] = ['basic', 'deep', 'advanced'];\n\n  /**\n   * Processes a raw input string and returns a parsed command\n   */\n  public processCommand(input: string, gameState: GameState): CommandResult {\n    const trimmed = input.trim();\n    \n    if (!trimmed) {\n      return { success: false, error: 'No command entered' };\n    }\n    \n    const tokens = trimmed.toLowerCase().split(/\\s+/);\n    const commandType = tokens[0];\n\n    try {\n      switch (commandType) {\n        case 'build':\n          return this.parseBuildCommand(tokens, gameState);\n        \n        case 'attack':\n          return this.parseAttackCommand(tokens, gameState);\n        \n        case 'scan':\n          return this.parseScanCommand(tokens, gameState);\n        \n        case 'status':\n          return { success: true, command: { type: 'status' } };\n        \n        case 'help':\n          return { success: true, command: { type: 'help' } };\n        \n        case 'end':\n        case 'endturn':\n        case 'end_turn':\n          return { success: true, command: { type: 'end_turn' } };\n        \n        case 'quit':\n        case 'exit':\n          return { success: true, command: { type: 'quit' } };\n        \n        default:\n          return { success: false, error: `Unknown command: ${commandType}. Type 'help' for available commands.` };\n      }\n    } catch (error) {\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Command parsing failed' \n      };\n    }\n  }\n\n  /**\n   * Parses build commands: \"build <quantity> <unit/structure>\"\n   */\n  private parseBuildCommand(tokens: string[], gameState: GameState): CommandResult {\n    if (tokens.length !== 3) {\n      return { \n        success: false, \n        error: 'Build command format: \"build <quantity> <unit/structure>\"\\nExample: \"build 10 frigate\" or \"build 1 reactor\"' \n      };\n    }\n\n    // Parse quantity\n    const quantityStr = tokens[1];\n    const quantity = parseInt(quantityStr, 10);\n    \n    if (isNaN(quantity) || quantity <= 0) {\n      return { success: false, error: 'Quantity must be a positive number' };\n    }\n\n    if (quantity > 10000) {\n      return { success: false, error: 'Quantity too large (maximum: 10,000)' };\n    }\n\n    // Parse build type\n    const buildTypeStr = tokens[2];\n    let buildType: BuildableType;\n\n    if (this.UNIT_TYPES.includes(buildTypeStr as UnitType)) {\n      buildType = buildTypeStr as UnitType;\n    } else if (this.STRUCTURE_TYPES.includes(buildTypeStr as StructureType)) {\n      buildType = buildTypeStr as StructureType;\n    } else {\n      const validTypes = [...this.UNIT_TYPES, ...this.STRUCTURE_TYPES].join(', ');\n      return { \n        success: false, \n        error: `Invalid build type: ${buildTypeStr}. Valid types: ${validTypes}` \n      };\n    }\n\n    // Validate resources\n    const validationResult = this.validateBuildCommand(buildType, quantity, gameState);\n    if (!validationResult.success) {\n      return validationResult;\n    }\n\n    return {\n      success: true,\n      command: {\n        type: 'build',\n        buildType,\n        quantity\n      }\n    };\n  }\n\n  /**\n   * Parses attack commands: \"attack <frigates> <cruisers> <battleships>\"\n   */\n  private parseAttackCommand(tokens: string[], gameState: GameState): CommandResult {\n    if (tokens.length !== 4) {\n      return { \n        success: false, \n        error: 'Attack command format: \"attack <frigates> <cruisers> <battleships>\"\\nExample: \"attack 50 20 10\"' \n      };\n    }\n\n    // Parse fleet composition\n    const frigates = parseInt(tokens[1], 10);\n    const cruisers = parseInt(tokens[2], 10);\n    const battleships = parseInt(tokens[3], 10);\n\n    if (isNaN(frigates) || isNaN(cruisers) || isNaN(battleships)) {\n      return { success: false, error: 'Fleet numbers must be valid integers' };\n    }\n\n    if (frigates < 0 || cruisers < 0 || battleships < 0) {\n      return { success: false, error: 'Fleet numbers cannot be negative' };\n    }\n\n    const totalShips = frigates + cruisers + battleships;\n    if (totalShips === 0) {\n      return { success: false, error: 'Cannot attack with empty fleet' };\n    }\n\n    const attackFleet: FleetComposition = { frigates, cruisers, battleships };\n\n    // Validate fleet availability\n    const validationResult = this.validateAttackCommand(attackFleet, gameState);\n    if (!validationResult.success) {\n      return validationResult;\n    }\n\n    return {\n      success: true,\n      command: {\n        type: 'attack',\n        attackFleet,\n        target: 'ai_system' // Default target for now\n      }\n    };\n  }\n\n  /**\n   * Parses scan commands: \"scan <type>\"\n   */\n  private parseScanCommand(tokens: string[], gameState: GameState): CommandResult {\n    if (tokens.length !== 2) {\n      return { \n        success: false, \n        error: 'Scan command format: \"scan <type>\"\\nValid types: basic, deep, advanced' \n      };\n    }\n\n    const scanTypeStr = tokens[1];\n    \n    if (!this.SCAN_TYPES.includes(scanTypeStr as ScanType)) {\n      return { \n        success: false, \n        error: `Invalid scan type: ${scanTypeStr}. Valid types: ${this.SCAN_TYPES.join(', ')}` \n      };\n    }\n\n    const scanType = scanTypeStr as ScanType;\n\n    // Validate energy cost\n    const validationResult = this.validateScanCommand(scanType, gameState);\n    if (!validationResult.success) {\n      return validationResult;\n    }\n\n    return {\n      success: true,\n      command: {\n        type: 'scan',\n        scanType\n      }\n    };\n  }\n\n  /**\n   * Validates build command against current game state\n   */\n  private validateBuildCommand(buildType: BuildableType, quantity: number, gameState: GameState): CommandResult {\n    const player = gameState.player;\n    const costs = this.getBuildCosts(buildType);\n    \n    const totalMetalCost = costs.metal * quantity;\n    const totalEnergyCost = costs.energy * quantity;\n\n    // Check if player has enough resources\n    if (player.resources.metal < totalMetalCost) {\n      return { \n        success: false, \n        error: `Insufficient metal. Need: ${totalMetalCost.toLocaleString()}, Have: ${player.resources.metal.toLocaleString()}` \n      };\n    }\n\n    if (player.resources.energy < totalEnergyCost) {\n      return { \n        success: false, \n        error: `Insufficient energy. Need: ${totalEnergyCost.toLocaleString()}, Have: ${player.resources.energy.toLocaleString()}` \n      };\n    }\n\n    // Check if economy can support the upkeep (for units)\n    if (this.UNIT_TYPES.includes(buildType as UnitType)) {\n      const upkeepCosts = this.getUpkeepCosts(buildType as UnitType);\n      const totalMetalUpkeep = upkeepCosts.metal * quantity;\n      const totalEnergyUpkeep = upkeepCosts.energy * quantity;\n      \n      const projectedMetalIncome = player.resources.metalIncome - totalMetalUpkeep;\n      const projectedEnergyIncome = player.resources.energyIncome - totalEnergyUpkeep;\n      \n      if (projectedMetalIncome < 0 || projectedEnergyIncome < 0) {\n        return { \n          success: false, \n          error: `Building ${quantity} ${buildType}(s) would cause economic stall. Upkeep: ${totalMetalUpkeep} Metal, ${totalEnergyUpkeep} Energy per turn` \n        };\n      }\n    }\n\n    return { success: true };\n  }\n\n  /**\n   * Validates attack command against current game state\n   */\n  private validateAttackCommand(attackFleet: FleetComposition, gameState: GameState): CommandResult {\n    const playerFleet = gameState.player.fleet.homeSystem;\n\n    // Check if player has enough ships\n    if (playerFleet.frigates < attackFleet.frigates) {\n      return { \n        success: false, \n        error: `Insufficient frigates. Need: ${attackFleet.frigates}, Have: ${playerFleet.frigates}` \n      };\n    }\n\n    if (playerFleet.cruisers < attackFleet.cruisers) {\n      return { \n        success: false, \n        error: `Insufficient cruisers. Need: ${attackFleet.cruisers}, Have: ${playerFleet.cruisers}` \n      };\n    }\n\n    if (playerFleet.battleships < attackFleet.battleships) {\n      return { \n        success: false, \n        error: `Insufficient battleships. Need: ${attackFleet.battleships}, Have: ${playerFleet.battleships}` \n      };\n    }\n\n    return { success: true };\n  }\n\n  /**\n   * Validates scan command against current game state\n   */\n  private validateScanCommand(scanType: ScanType, gameState: GameState): CommandResult {\n    const player = gameState.player;\n    const cost = SCAN_COSTS[scanType];\n\n    if (player.resources.energy < cost.energy) {\n      return { \n        success: false, \n        error: `Insufficient energy for ${scanType} scan. Need: ${cost.energy}, Have: ${player.resources.energy}` \n      };\n    }\n\n    return { success: true };\n  }\n\n  /**\n   * Gets build costs for different unit/structure types\n   */\n  private getBuildCosts(buildType: BuildableType): { metal: number; energy: number } {\n    const costs = {\n      // Units (construction costs)\n      frigate: { metal: 4, energy: 2 },\n      cruiser: { metal: 10, energy: 6 },\n      battleship: { metal: 20, energy: 12 },\n      \n      // Structures\n      reactor: { metal: 900, energy: 1200 },\n      mine: { metal: 1500, energy: 600 }\n    };\n\n    return costs[buildType];\n  }\n\n  /**\n   * Gets upkeep costs for unit types\n   */\n  private getUpkeepCosts(unitType: UnitType): { metal: number; energy: number } {\n    const upkeepCosts = {\n      frigate: { metal: 2, energy: 1 },\n      cruiser: { metal: 5, energy: 3 },\n      battleship: { metal: 10, energy: 6 }\n    };\n\n    return upkeepCosts[unitType];\n  }\n\n  /**\n   * Provides command suggestions based on partial input\n   */\n  public getCommandSuggestions(partialInput: string): string[] {\n    const commands = ['build', 'attack', 'scan', 'status', 'help', 'end', 'quit'];\n    const partial = partialInput.toLowerCase().trim();\n    \n    return commands.filter(cmd => cmd.startsWith(partial));\n  }\n\n  /**\n   * Validates if a command string has correct syntax without game state validation\n   */\n  public validateSyntax(input: string): { valid: boolean; error?: string } {\n    const tokens = input.toLowerCase().trim().split(/\\s+/);\n    \n    if (tokens.length === 0) {\n      return { valid: false, error: 'No command entered' };\n    }\n\n    const commandType = tokens[0];\n\n    switch (commandType) {\n      case 'build':\n        if (tokens.length !== 3) {\n          return { valid: false, error: 'Build command requires: build <quantity> <unit/structure>' };\n        }\n        if (isNaN(parseInt(tokens[1], 10))) {\n          return { valid: false, error: 'Quantity must be a number' };\n        }\n        break;\n\n      case 'attack':\n        if (tokens.length !== 4) {\n          return { valid: false, error: 'Attack command requires: attack <frigates> <cruisers> <battleships>' };\n        }\n        for (let i = 1; i < 4; i++) {\n          if (isNaN(parseInt(tokens[i], 10))) {\n            return { valid: false, error: 'Fleet numbers must be integers' };\n          }\n        }\n        break;\n\n      case 'scan':\n        if (tokens.length !== 2) {\n          return { valid: false, error: 'Scan command requires: scan <type>' };\n        }\n        if (!this.SCAN_TYPES.includes(tokens[1] as ScanType)) {\n          return { valid: false, error: `Invalid scan type. Valid types: ${this.SCAN_TYPES.join(', ')}` };\n        }\n        break;\n\n      case 'status':\n      case 'help':\n      case 'end':\n      case 'endturn':\n      case 'end_turn':\n      case 'quit':\n      case 'exit':\n        // These commands don't need additional parameters\n        break;\n\n      default:\n        return { valid: false, error: `Unknown command: ${commandType}` };\n    }\n\n    return { valid: true };\n  }\n}","import { GameEngine, TurnResult } from '../engine/GameEngine.js';\nimport { GameState, FleetComposition } from '../models/GameState.js';\nimport { PlayerState, BuildableType, UnitType, StructureType } from '../models/PlayerState.js';\nimport { ScanType, SCAN_COSTS } from '../models/Intelligence.js';\nimport { Command } from './InputHandler.js';\nimport { createStructureBuildOrder, createUnitBuildOrder } from '../models/Economy.js';\nimport { UNIT_STATS } from '../models/Fleet.js';\n\nexport interface CommandExecutionResult {\n  success: boolean;\n  message: string;\n  gameStateChanged: boolean;\n}\n\nexport class GameController {\n  private gameEngine: GameEngine;\n  private pendingPlayerActions: Command[] = [];\n  private lastTurnResult: TurnResult | null = null;\n\n  constructor(gameEngine: GameEngine) {\n    this.gameEngine = gameEngine;\n  }\n\n  /**\n   * Executes a player command and returns the result\n   */\n  public executeCommand(command: Command): CommandExecutionResult {\n    try {\n      switch (command.type) {\n        case 'build':\n          return this.executeBuildCommand(command);\n        \n        case 'attack':\n          return this.executeAttackCommand(command);\n        \n        case 'scan':\n          return this.executeScanCommand(command);\n        \n        case 'status':\n        case 'help':\n          // These are display-only commands, no game state change\n          return {\n            success: true,\n            message: 'Information displayed',\n            gameStateChanged: false\n          };\n        \n        case 'end_turn':\n          return this.executeEndTurn();\n        \n        default:\n          return {\n            success: false,\n            message: `Unknown command type: ${command.type}`,\n            gameStateChanged: false\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: `Command execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        gameStateChanged: false\n      };\n    }\n  }\n\n  /**\n   * Executes a build command\n   */\n  private executeBuildCommand(command: Command): CommandExecutionResult {\n    if (!command.buildType || !command.quantity) {\n      return {\n        success: false,\n        message: 'Invalid build command: missing build type or quantity',\n        gameStateChanged: false\n      };\n    }\n\n    const gameState = this.gameEngine.getGameState();\n    const player = gameState.player;\n    \n    // Calculate costs\n    const costs = this.getBuildCosts(command.buildType);\n    const totalMetalCost = costs.metal * command.quantity;\n    const totalEnergyCost = costs.energy * command.quantity;\n\n    // Validate resources\n    if (player.resources.metal < totalMetalCost) {\n      return {\n        success: false,\n        message: `Insufficient metal. Need: ${totalMetalCost.toLocaleString()}, Have: ${player.resources.metal.toLocaleString()}`,\n        gameStateChanged: false\n      };\n    }\n\n    if (player.resources.energy < totalEnergyCost) {\n      return {\n        success: false,\n        message: `Insufficient energy. Need: ${totalEnergyCost.toLocaleString()}, Have: ${player.resources.energy.toLocaleString()}`,\n        gameStateChanged: false\n      };\n    }\n\n    // Create build order\n    let buildOrder;\n    try {\n      if (command.buildType === 'reactor' || command.buildType === 'mine') {\n        // Structure build order\n        const currentCount = command.buildType === 'reactor' ? \n          player.economy.reactors : \n          player.economy.mines;\n        \n        buildOrder = createStructureBuildOrder(command.buildType, command.quantity, currentCount);\n      } else {\n        // Unit build order\n        const unitStats = UNIT_STATS[command.buildType as UnitType];\n        buildOrder = createUnitBuildOrder(command.buildType as UnitType, command.quantity, unitStats);\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: `Failed to create build order: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        gameStateChanged: false\n      };\n    }\n\n    // Deduct resources immediately\n    player.resources.metal -= totalMetalCost;\n    player.resources.energy -= totalEnergyCost;\n\n    // Add to construction queue\n    player.economy.constructionQueue.push(buildOrder);\n\n    // Add to pending actions for turn processing\n    this.pendingPlayerActions.push(command);\n\n    const itemName = command.buildType;\n    return {\n      success: true,\n      message: `Started building ${command.quantity} ${itemName}(s). Cost: ${totalMetalCost} Metal, ${totalEnergyCost} Energy`,\n      gameStateChanged: true\n    };\n  }\n\n  /**\n   * Executes an attack command\n   */\n  private executeAttackCommand(command: Command): CommandExecutionResult {\n    if (!command.attackFleet || !command.target) {\n      return {\n        success: false,\n        message: 'Invalid attack command: missing fleet composition or target',\n        gameStateChanged: false\n      };\n    }\n\n    const gameState = this.gameEngine.getGameState();\n    const playerFleet = gameState.player.fleet.homeSystem;\n    const attackFleet = command.attackFleet;\n\n    // Validate fleet availability\n    if (playerFleet.frigates < attackFleet.frigates) {\n      return {\n        success: false,\n        message: `Insufficient frigates. Need: ${attackFleet.frigates}, Have: ${playerFleet.frigates}`,\n        gameStateChanged: false\n      };\n    }\n\n    if (playerFleet.cruisers < attackFleet.cruisers) {\n      return {\n        success: false,\n        message: `Insufficient cruisers. Need: ${attackFleet.cruisers}, Have: ${playerFleet.cruisers}`,\n        gameStateChanged: false\n      };\n    }\n\n    if (playerFleet.battleships < attackFleet.battleships) {\n      return {\n        success: false,\n        message: `Insufficient battleships. Need: ${attackFleet.battleships}, Have: ${playerFleet.battleships}`,\n        gameStateChanged: false\n      };\n    }\n\n    // Deduct fleet from home system\n    playerFleet.frigates -= attackFleet.frigates;\n    playerFleet.cruisers -= attackFleet.cruisers;\n    playerFleet.battleships -= attackFleet.battleships;\n\n    // Create fleet movement\n    const movement = {\n      composition: attackFleet,\n      target: command.target,\n      arrivalTurn: gameState.turn + 1, // Arrives next turn\n      returnTurn: gameState.turn + 3,   // Returns in 3 turns\n      missionType: 'outbound' as const\n    };\n\n    // Add to outbound movements\n    gameState.player.fleet.inTransit.outbound.push(movement);\n\n    // Add to pending actions for turn processing\n    this.pendingPlayerActions.push(command);\n\n    const totalShips = attackFleet.frigates + attackFleet.cruisers + attackFleet.battleships;\n    return {\n      success: true,\n      message: `Fleet launched! ${totalShips} ships en route to ${command.target}. Arrival: Turn ${movement.arrivalTurn}, Return: Turn ${movement.returnTurn}`,\n      gameStateChanged: true\n    };\n  }\n\n  /**\n   * Executes a scan command\n   */\n  private executeScanCommand(command: Command): CommandExecutionResult {\n    if (!command.scanType) {\n      return {\n        success: false,\n        message: 'Invalid scan command: missing scan type',\n        gameStateChanged: false\n      };\n    }\n\n    const gameState = this.gameEngine.getGameState();\n    const player = gameState.player;\n    const cost = SCAN_COSTS[command.scanType];\n\n    // Validate energy cost\n    if (player.resources.energy < cost.energy) {\n      return {\n        success: false,\n        message: `Insufficient energy for ${command.scanType} scan. Need: ${cost.energy}, Have: ${player.resources.energy}`,\n        gameStateChanged: false\n      };\n    }\n\n    // Deduct energy cost\n    player.resources.energy -= cost.energy;\n\n    // Perform the scan using the intelligence engine\n    try {\n      // Get the intelligence engine from the game engine (we'll need to expose this)\n      // For now, we'll simulate the scan result\n      const scanResult = this.performScan(command.scanType, gameState);\n      \n      // Update player intelligence\n      player.intelligence.lastScanTurn = gameState.turn;\n      if (scanResult.fleetData) {\n        player.intelligence.knownEnemyFleet = {\n          frigates: scanResult.fleetData.frigates || 0,\n          cruisers: scanResult.fleetData.cruisers || 0,\n          battleships: scanResult.fleetData.battleships || 0\n        };\n      }\n\n      // Add to pending actions for turn processing\n      this.pendingPlayerActions.push(command);\n\n      return {\n        success: true,\n        message: this.formatScanResult(command.scanType, scanResult),\n        gameStateChanged: true\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: `Scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        gameStateChanged: false\n      };\n    }\n  }\n\n  /**\n   * Executes end turn command\n   */\n  private executeEndTurn(): CommandExecutionResult {\n    try {\n      // Process the turn with all pending actions\n      const turnResult = this.gameEngine.processTurn(this.pendingPlayerActions);\n      \n      // Store the turn result for display\n      this.lastTurnResult = turnResult;\n      \n      // Clear pending actions\n      this.pendingPlayerActions = [];\n\n      if (turnResult.success) {\n        let message = `Turn ${this.gameEngine.getCurrentTurn() - 1} completed.`;\n        \n        if (turnResult.combatEvents.length > 0) {\n          message += ` ${turnResult.combatEvents.length} combat event(s) occurred.`;\n        }\n        \n        if (turnResult.gameEnded) {\n          message += ` Game Over! Winner: ${turnResult.winner}`;\n        }\n\n        return {\n          success: true,\n          message,\n          gameStateChanged: true\n        };\n      } else {\n        return {\n          success: false,\n          message: `Turn processing failed: ${turnResult.errors.join(', ')}`,\n          gameStateChanged: false\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: `Turn processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        gameStateChanged: false\n      };\n    }\n  }\n\n  /**\n   * Performs a scan and returns the result\n   */\n  private performScan(scanType: ScanType, gameState: GameState): any {\n    const aiFleet = gameState.ai.fleet.homeSystem;\n    const totalShips = aiFleet.frigates + aiFleet.cruisers + aiFleet.battleships;\n\n    switch (scanType) {\n      case 'basic':\n        // Basic scan: total fleet count with Â±30% accuracy\n        const accuracy = 0.7 + (Math.random() - 0.5) * 0.6; // 0.4 to 1.0\n        const reportedTotal = Math.max(0, Math.round(totalShips * accuracy));\n        return {\n          scanType: 'basic',\n          fleetData: {\n            frigates: reportedTotal,\n            cruisers: 0,\n            battleships: 0\n          },\n          message: `Enemy fleet detected: approximately ${reportedTotal} ships`\n        };\n\n      case 'deep':\n        // Deep scan: unit composition with Â±10% accuracy\n        const applyAccuracy = (value: number): number => {\n          const factor = 0.9 + Math.random() * 0.2; // 0.9 to 1.1\n          return Math.max(0, Math.round(value * factor));\n        };\n        \n        return {\n          scanType: 'deep',\n          fleetData: {\n            frigates: applyAccuracy(aiFleet.frigates),\n            cruisers: applyAccuracy(aiFleet.cruisers),\n            battleships: applyAccuracy(aiFleet.battleships)\n          },\n          economicData: {\n            reactors: gameState.ai.economy.reactors,\n            mines: gameState.ai.economy.mines\n          },\n          message: `Detailed scan complete: ${applyAccuracy(aiFleet.frigates)} Frigates, ${applyAccuracy(aiFleet.cruisers)} Cruisers, ${applyAccuracy(aiFleet.battleships)} Battleships. Economic structures: ${gameState.ai.economy.reactors} Reactors, ${gameState.ai.economy.mines} Mines`\n        };\n\n      case 'advanced':\n        // Advanced scan: strategic intent\n        const intent = this.determineAIIntent(gameState);\n        return {\n          scanType: 'advanced',\n          fleetData: {\n            frigates: Math.floor(totalShips * 0.5),\n            cruisers: Math.floor(totalShips * 0.3),\n            battleships: Math.floor(totalShips * 0.2)\n          },\n          strategicIntent: intent,\n          message: `Advanced scan reveals: ${intent}. Estimated fleet composition provided.`\n        };\n\n      default:\n        throw new Error(`Unknown scan type: ${scanType}`);\n    }\n  }\n\n  /**\n   * Determines AI strategic intent for advanced scans\n   */\n  private determineAIIntent(gameState: GameState): string {\n    const aiFleet = gameState.ai.fleet.homeSystem;\n    const totalShips = aiFleet.frigates + aiFleet.cruisers + aiFleet.battleships;\n    const aiIncome = gameState.ai.resources.metalIncome + gameState.ai.resources.energyIncome;\n    const structures = gameState.ai.economy.reactors + gameState.ai.economy.mines;\n\n    if (totalShips > 100) {\n      return \"AI is preparing for major offensive operations\";\n    } else if (structures > 3) {\n      return \"AI is focusing on economic expansion\";\n    } else if (aiIncome > 25000) {\n      return \"AI has strong economic foundation, likely planning military buildup\";\n    } else if (totalShips < 20) {\n      return \"AI appears to be in defensive posture\";\n    } else {\n      return \"AI strategy unclear - balanced military and economic development\";\n    }\n  }\n\n  /**\n   * Formats scan results for display\n   */\n  private formatScanResult(scanType: ScanType, result: any): string {\n    return result.message || `${scanType} scan completed`;\n  }\n\n  /**\n   * Gets build costs for different unit/structure types\n   */\n  private getBuildCosts(buildType: BuildableType): { metal: number; energy: number } {\n    const costs = {\n      // Units (construction costs)\n      frigate: { metal: 4, energy: 2 },\n      cruiser: { metal: 10, energy: 6 },\n      battleship: { metal: 20, energy: 12 },\n      \n      // Structures\n      reactor: { metal: 900, energy: 1200 },\n      mine: { metal: 1500, energy: 600 }\n    };\n\n    return costs[buildType];\n  }\n\n  /**\n   * Gets pending player actions (for debugging)\n   */\n  public getPendingActions(): Command[] {\n    return [...this.pendingPlayerActions];\n  }\n\n  /**\n   * Clears pending actions (for testing)\n   */\n  public clearPendingActions(): void {\n    this.pendingPlayerActions = [];\n  }\n\n  /**\n   * Gets the last turn result for display\n   */\n  public getLastTurnResult(): TurnResult | null {\n    return this.lastTurnResult;\n  }\n\n  /**\n   * Gets the game engine instance\n   */\n  public getGameEngine(): GameEngine {\n    return this.gameEngine;\n  }\n}","export interface GameError {\n  type: 'validation' | 'runtime' | 'user_input' | 'system' | 'game_logic';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  message: string;\n  context?: any;\n  timestamp: Date;\n  recoverable: boolean;\n}\n\nexport class ErrorHandler {\n  private static errors: GameError[] = [];\n  private static maxErrorHistory = 100;\n\n  /**\n   * Logs an error and determines if the game can continue\n   */\n  public static handleError(\n    type: GameError['type'],\n    severity: GameError['severity'],\n    message: string,\n    context?: any\n  ): {\n    canContinue: boolean;\n    userMessage: string;\n    shouldRestart: boolean;\n  } {\n    const error: GameError = {\n      type,\n      severity,\n      message,\n      context,\n      timestamp: new Date(),\n      recoverable: this.isRecoverable(type, severity)\n    };\n\n    // Add to error history\n    this.errors.push(error);\n    if (this.errors.length > this.maxErrorHistory) {\n      this.errors.shift();\n    }\n\n    // Log to console in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(`[${severity.toUpperCase()}] ${type}: ${message}`, context);\n    }\n\n    // Determine response based on severity\n    switch (severity) {\n      case 'critical':\n        return {\n          canContinue: false,\n          userMessage: `Critical error: ${message}. The game must restart.`,\n          shouldRestart: true\n        };\n\n      case 'high':\n        return {\n          canContinue: error.recoverable,\n          userMessage: `Serious error: ${message}. ${error.recoverable ? 'Attempting to continue...' : 'Game may be unstable.'}`,\n          shouldRestart: !error.recoverable\n        };\n\n      case 'medium':\n        return {\n          canContinue: true,\n          userMessage: `Error: ${message}. Game will continue.`,\n          shouldRestart: false\n        };\n\n      case 'low':\n        return {\n          canContinue: true,\n          userMessage: `Warning: ${message}`,\n          shouldRestart: false\n        };\n\n      default:\n        return {\n          canContinue: true,\n          userMessage: message,\n          shouldRestart: false\n        };\n    }\n  }\n\n  /**\n   * Determines if an error type/severity combination is recoverable\n   */\n  private static isRecoverable(type: GameError['type'], severity: GameError['severity']): boolean {\n    // Critical errors are never recoverable\n    if (severity === 'critical') {\n      return false;\n    }\n\n    // Type-specific recoverability\n    switch (type) {\n      case 'validation':\n        return severity !== 'high'; // High validation errors usually indicate corrupted state\n      \n      case 'runtime':\n        return severity === 'low' || severity === 'medium';\n      \n      case 'user_input':\n        return true; // User input errors are always recoverable\n      \n      case 'system':\n        return severity === 'low'; // System errors are usually not recoverable\n      \n      case 'game_logic':\n        return severity !== 'high'; // High game logic errors indicate serious bugs\n      \n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Handles common game state validation errors\n   */\n  public static handleGameStateError(validationErrors: string[]): {\n    canContinue: boolean;\n    userMessage: string;\n    shouldRestart: boolean;\n  } {\n    if (validationErrors.length === 0) {\n      return { canContinue: true, userMessage: '', shouldRestart: false };\n    }\n\n    // Categorize validation errors by severity\n    const criticalErrors = validationErrors.filter(error => \n      error.includes('negative') || \n      error.includes('null') || \n      error.includes('undefined') ||\n      error.includes('missing')\n    );\n\n    const highErrors = validationErrors.filter(error => \n      error.includes('inconsistent') || \n      error.includes('invalid state') ||\n      error.includes('corrupted')\n    );\n\n    if (criticalErrors.length > 0) {\n      return this.handleError(\n        'validation',\n        'critical',\n        `Game state validation failed: ${criticalErrors.join(', ')}`,\n        { allErrors: validationErrors }\n      );\n    } else if (highErrors.length > 0) {\n      return this.handleError(\n        'validation',\n        'high',\n        `Game state issues detected: ${highErrors.join(', ')}`,\n        { allErrors: validationErrors }\n      );\n    } else {\n      return this.handleError(\n        'validation',\n        'medium',\n        `Minor game state issues: ${validationErrors.join(', ')}`,\n        { allErrors: validationErrors }\n      );\n    }\n  }\n\n  /**\n   * Handles turn processing errors\n   */\n  public static handleTurnProcessingError(turnErrors: string[]): {\n    canContinue: boolean;\n    userMessage: string;\n    shouldRestart: boolean;\n  } {\n    if (turnErrors.length === 0) {\n      return { canContinue: true, userMessage: '', shouldRestart: false };\n    }\n\n    // Check for critical turn processing errors\n    const hasCriticalError = turnErrors.some(error => \n      error.includes('failed to process') ||\n      error.includes('engine failure') ||\n      error.includes('system crash')\n    );\n\n    if (hasCriticalError) {\n      return this.handleError(\n        'game_logic',\n        'critical',\n        `Turn processing failed: ${turnErrors.join(', ')}`,\n        { turnErrors }\n      );\n    } else {\n      return this.handleError(\n        'game_logic',\n        'medium',\n        `Turn processing issues: ${turnErrors.join(', ')}`,\n        { turnErrors }\n      );\n    }\n  }\n\n  /**\n   * Handles user input errors\n   */\n  public static handleUserInputError(inputError: string): {\n    canContinue: boolean;\n    userMessage: string;\n    shouldRestart: boolean;\n  } {\n    return this.handleError(\n      'user_input',\n      'low',\n      inputError\n    );\n  }\n\n  /**\n   * Handles system-level errors (file I/O, memory, etc.)\n   */\n  public static handleSystemError(error: Error): {\n    canContinue: boolean;\n    userMessage: string;\n    shouldRestart: boolean;\n  } {\n    // Categorize system errors\n    const isMemoryError = error.message.includes('memory') || error.message.includes('heap');\n    const isFileError = error.message.includes('file') || error.message.includes('ENOENT');\n    const isNetworkError = error.message.includes('network') || error.message.includes('connection');\n\n    if (isMemoryError) {\n      return this.handleError(\n        'system',\n        'critical',\n        `Memory error: ${error.message}`,\n        { error }\n      );\n    } else if (isFileError) {\n      return this.handleError(\n        'system',\n        'high',\n        `File system error: ${error.message}`,\n        { error }\n      );\n    } else if (isNetworkError) {\n      return this.handleError(\n        'system',\n        'medium',\n        `Network error: ${error.message}`,\n        { error }\n      );\n    } else {\n      return this.handleError(\n        'system',\n        'high',\n        `System error: ${error.message}`,\n        { error }\n      );\n    }\n  }\n\n  /**\n   * Gets recent error history\n   */\n  public static getRecentErrors(count: number = 10): GameError[] {\n    return this.errors.slice(-count);\n  }\n\n  /**\n   * Gets error statistics\n   */\n  public static getErrorStatistics(): {\n    total: number;\n    byType: Record<GameError['type'], number>;\n    bySeverity: Record<GameError['severity'], number>;\n    recentCritical: number;\n  } {\n    const byType: Record<GameError['type'], number> = {\n      validation: 0,\n      runtime: 0,\n      user_input: 0,\n      system: 0,\n      game_logic: 0\n    };\n\n    const bySeverity: Record<GameError['severity'], number> = {\n      low: 0,\n      medium: 0,\n      high: 0,\n      critical: 0\n    };\n\n    let recentCritical = 0;\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n\n    this.errors.forEach(error => {\n      byType[error.type]++;\n      bySeverity[error.severity]++;\n      \n      if (error.severity === 'critical' && error.timestamp > oneHourAgo) {\n        recentCritical++;\n      }\n    });\n\n    return {\n      total: this.errors.length,\n      byType,\n      bySeverity,\n      recentCritical\n    };\n  }\n\n  /**\n   * Clears error history\n   */\n  public static clearErrorHistory(): void {\n    this.errors = [];\n  }\n\n  /**\n   * Checks if the system is in a healthy state\n   */\n  public static isSystemHealthy(): {\n    healthy: boolean;\n    issues: string[];\n  } {\n    const issues: string[] = [];\n    const stats = this.getErrorStatistics();\n\n    // Check for too many recent critical errors\n    if (stats.recentCritical > 3) {\n      issues.push(`Too many critical errors in the last hour: ${stats.recentCritical}`);\n    }\n\n    // Check for high error rate\n    if (stats.total > 50) {\n      issues.push(`High total error count: ${stats.total}`);\n    }\n\n    // Check for system errors\n    if (stats.byType.system > 5) {\n      issues.push(`Multiple system errors detected: ${stats.byType.system}`);\n    }\n\n    return {\n      healthy: issues.length === 0,\n      issues\n    };\n  }\n\n  /**\n   * Provides recovery suggestions based on error patterns\n   */\n  public static getRecoverySuggestions(): string[] {\n    const suggestions: string[] = [];\n    const stats = this.getErrorStatistics();\n\n    if (stats.byType.validation > 5) {\n      suggestions.push('Consider restarting the game to reset the game state');\n    }\n\n    if (stats.byType.system > 3) {\n      suggestions.push('Check system resources (memory, disk space)');\n    }\n\n    if (stats.byType.user_input > 10) {\n      suggestions.push('Review command syntax - type \"help\" for available commands');\n    }\n\n    if (stats.recentCritical > 0) {\n      suggestions.push('Recent critical errors detected - restart recommended');\n    }\n\n    if (suggestions.length === 0) {\n      suggestions.push('System appears stable');\n    }\n\n    return suggestions;\n  }\n}","import { GameEngine, TurnResult } from '../engine/GameEngine.js';\nimport { GameDisplay } from './GameDisplay.js';\nimport { InputHandler, CommandResult } from './InputHandler.js';\nimport { GameController } from './GameController.js';\nimport { ErrorHandler } from '../ErrorHandler.js';\n\nexport interface CLIConfig {\n  showDebugInfo?: boolean;\n  autoAdvanceTurn?: boolean;\n  useColors?: boolean;\n  combatDisplay?: {\n    showTacticalAnalysis?: boolean;\n    showBattlePhases?: boolean;\n    detailedCasualties?: boolean;\n    useEnhancedFormatting?: boolean;\n  };\n}\n\nexport class CLIInterface {\n  private gameEngine: GameEngine;\n  private gameController: GameController;\n  private gameDisplay: GameDisplay;\n  private inputHandler: InputHandler;\n  private config: CLIConfig;\n  private isRunning: boolean = false;\n\n  constructor(gameEngine: GameEngine, config: CLIConfig = {}) {\n    this.gameEngine = gameEngine;\n    this.gameController = new GameController(gameEngine);\n    this.gameDisplay = new GameDisplay(config);\n    this.inputHandler = new InputHandler();\n    this.config = {\n      // Set default combat display preferences\n      combatDisplay: {\n        showTacticalAnalysis: true,\n        showBattlePhases: true,\n        detailedCasualties: true,\n        useEnhancedFormatting: true,\n        ...config.combatDisplay\n      },\n      ...config\n    };\n  }\n\n  /**\n   * Starts the CLI game loop\n   */\n  public async start(): Promise<void> {\n    this.isRunning = true;\n    \n    // Display welcome message and initial game state\n    this.displayWelcome();\n    this.displayGameState();\n    \n    // Main game loop\n    while (this.isRunning && !this.gameEngine.isGameOver()) {\n      await this.processPlayerTurn();\n    }\n    \n    // Display game over message\n    if (this.gameEngine.isGameOver()) {\n      this.displayGameOver();\n    }\n  }\n\n  /**\n   * Stops the CLI interface\n   */\n  public stop(): void {\n    this.isRunning = false;\n  }\n\n  /**\n   * Displays the welcome message and game instructions\n   */\n  private displayWelcome(): void {\n    console.clear();\n    console.log('='.repeat(60));\n    console.log('                    BURN RATE                    ');\n    console.log('='.repeat(60));\n    console.log('');\n    console.log('Welcome to Burn Rate - A fast-paced strategy game');\n    console.log('');\n    console.log('OBJECTIVE: Eliminate the AI through military or economic victory');\n    console.log('- Military Victory: Destroy all enemy fleets');\n    console.log('- Economic Victory: Force enemy economy to collapse');\n    console.log('');\n    console.log('Type \"help\" for available commands');\n    console.log('Type \"status\" to see detailed game information');\n    console.log('');\n  }\n\n  /**\n   * Processes a single player turn\n   */\n  private async processPlayerTurn(): Promise<void> {\n    let turnComplete = false;\n\n    console.log(`\\n--- TURN ${this.gameEngine.getCurrentTurn()} ---`);\n    \n    while (!turnComplete && this.isRunning) {\n      try {\n        // Validate game state before processing\n        const gameStateValidation = this.gameEngine.validateGameState();\n        if (!gameStateValidation.isValid) {\n          const errorResponse = ErrorHandler.handleGameStateError(gameStateValidation.errors);\n          this.gameDisplay.displayError(errorResponse.userMessage);\n          \n          if (!errorResponse.canContinue) {\n            this.isRunning = false;\n            return;\n          }\n        }\n\n        // Display current game state\n        this.displayGameState();\n        \n        // Get player input\n        const input = await this.getPlayerInput();\n        \n        if (!input.trim()) {\n          continue;\n        }\n\n        // Process command with error handling\n        const commandResult = this.processCommandSafely(input);\n        \n        if (commandResult.success && commandResult.command) {\n          // Execute the command using the game controller\n          const executionResult = this.gameController.executeCommand(commandResult.command);\n          \n          if (executionResult.success) {\n            console.log(`âœ“ ${executionResult.message}`);\n            \n            // Handle special command types\n            switch (commandResult.command.type) {\n              case 'status':\n                this.displayDetailedStatus();\n                break;\n                \n              case 'help':\n                this.displayHelp();\n                break;\n                \n              case 'end_turn':\n                // Display turn result after processing\n                const turnResult = this.gameController.getLastTurnResult();\n                if (turnResult) {\n                  this.displayTurnResult(turnResult);\n                }\n                turnComplete = true;\n                break;\n                \n              case 'quit':\n                this.isRunning = false;\n                return;\n            }\n          } else {\n            const errorResponse = ErrorHandler.handleUserInputError(executionResult.message);\n            this.gameDisplay.displayError(errorResponse.userMessage);\n          }\n        } else {\n          const errorResponse = ErrorHandler.handleUserInputError(commandResult.error || 'Invalid command');\n          this.gameDisplay.displayError(errorResponse.userMessage);\n        }\n\n      } catch (error) {\n        const errorResponse = ErrorHandler.handleSystemError(error instanceof Error ? error : new Error('Unknown error'));\n        this.gameDisplay.displayError(errorResponse.userMessage);\n        \n        if (!errorResponse.canContinue) {\n          this.isRunning = false;\n          return;\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets input from the player\n   */\n  private async getPlayerInput(): Promise<string> {\n    return new Promise((resolve) => {\n      process.stdout.write('\\n> ');\n      \n      const handleInput = (data: Buffer) => {\n        const input = data.toString().trim();\n        process.stdin.removeListener('data', handleInput);\n        resolve(input);\n      };\n      \n      process.stdin.on('data', handleInput);\n    });\n  }\n\n  /**\n   * Displays the current game state\n   */\n  private displayGameState(): void {\n    const gameState = this.gameEngine.getGameState();\n    this.gameDisplay.displayGameState(gameState);\n  }\n\n  /**\n   * Displays detailed game status\n   */\n  private displayDetailedStatus(): void {\n    const gameState = this.gameEngine.getGameState();\n    const stats = this.gameEngine.getGameStatistics();\n    this.gameDisplay.displayDetailedStatus(gameState, stats);\n  }\n\n  /**\n   * Displays help information\n   */\n  private displayHelp(): void {\n    this.gameDisplay.displayHelp();\n  }\n\n  /**\n   * Displays turn result including combat events\n   */\n  private displayTurnResult(turnResult: TurnResult): void {\n    this.gameDisplay.displayTurnResult(turnResult);\n  }\n\n  /**\n   * Displays game over message\n   */\n  private displayGameOver(): void {\n    const gameState = this.gameEngine.getGameState();\n    this.gameDisplay.displayGameOver(gameState);\n  }\n\n\n\n  /**\n   * Gets the current game engine instance\n   */\n  public getGameEngine(): GameEngine {\n    return this.gameEngine;\n  }\n\n  /**\n   * Processes a command with comprehensive error handling\n   */\n  private processCommandSafely(input: string): CommandResult {\n    try {\n      return this.inputHandler.processCommand(input, this.gameEngine.getGameState());\n    } catch (error) {\n      return {\n        success: false,\n        error: `Command processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      };\n    }\n  }\n\n  /**\n   * Performs a system health check\n   */\n  public performHealthCheck(): {\n    healthy: boolean;\n    issues: string[];\n    suggestions: string[];\n  } {\n    const systemHealth = ErrorHandler.isSystemHealthy();\n    const suggestions = ErrorHandler.getRecoverySuggestions();\n    \n    return {\n      healthy: systemHealth.healthy,\n      issues: systemHealth.issues,\n      suggestions\n    };\n  }\n\n  /**\n   * Displays system health information\n   */\n  public displayHealthCheck(): void {\n    const health = this.performHealthCheck();\n    \n    console.log('\\n' + '='.repeat(60));\n    console.log('SYSTEM HEALTH CHECK');\n    console.log('='.repeat(60));\n    \n    if (health.healthy) {\n      console.log('âœ… System is healthy');\n    } else {\n      console.log('âš ï¸  System issues detected:');\n      health.issues.forEach(issue => {\n        console.log(`  - ${issue}`);\n      });\n    }\n    \n    if (health.suggestions.length > 0) {\n      console.log('\\nSuggestions:');\n      health.suggestions.forEach(suggestion => {\n        console.log(`  - ${suggestion}`);\n      });\n    }\n    \n    const errorStats = ErrorHandler.getErrorStatistics();\n    console.log(`\\nError Statistics: ${errorStats.total} total errors`);\n    console.log(`Recent Critical: ${errorStats.recentCritical}`);\n  }\n\n  /**\n   * Resets the game with new configuration\n   */\n  public resetGame(config?: any): void {\n    try {\n      this.gameEngine.resetGame(config);\n      ErrorHandler.clearErrorHistory();\n      console.log('\\nGame reset! Starting new game...\\n');\n    } catch (error) {\n      const errorResponse = ErrorHandler.handleSystemError(error instanceof Error ? error : new Error('Reset failed'));\n      this.gameDisplay.displayError(errorResponse.userMessage);\n    }\n  }\n\n  /**\n   * Gracefully shuts down the CLI interface\n   */\n  public async shutdown(): Promise<void> {\n    console.log('\\nShutting down game...');\n    \n    // Perform final health check\n    const health = this.performHealthCheck();\n    if (!health.healthy) {\n      console.log('âš ï¸  Issues detected during shutdown:');\n      health.issues.forEach(issue => console.log(`  - ${issue}`));\n    }\n    \n    this.isRunning = false;\n    console.log('Goodbye!');\n  }\n}"],"names":["ColorManager","constructor","enableColors","__publicField","this","theme","getDefaultTheme","colorSupported","detectColorSupport","colorsEnabled","victory","defeat","neutral","player","enemy","frigate","cruiser","battleship","casualties","survivors","reset","validateNumericValue","value","fieldName","min","max","Number","MAX_SAFE_INTEGER","isNaN","isFinite","Math","floor","term","define_process_env_default","TERM","toLowerCase","colorTerm","COLORTERM","hasColorTerm","some","includes","colorType","forceColor","FORCE_COLOR","NO_COLOR","process","stdout","isTTY","colorize","text","String","colorCode","resetCode","error","formatFleetComposition","fleet","showColors","frigates","cruisers","battleships","frigateText","cruiserText","formatBattleOutcome","outcome","perspective","formattedOutcome","toUpperCase","replace","formatCasualties","total","validCasualties","validTotal","casualtyText","round","formatSurvivors","survivorText","formatPlayerIdentifier","playerType","createSeparator","length","char","validLength","safeChar","charAt","separator","repeat","setColorsEnabled","enabled","areColorsEnabled","isColorSupported","setTheme","getTheme","resetTheme","TacticalAnalyzer","calculateUnitEffectiveness","unitType","unitCount","enemyFleet","stats","UNIT_STATS","totalEnemyUnits","frigateWeight","cruiserWeight","battleshipWeight","effectiveness","vsFrigate","vsCruiser","vsBattleship","determineBattleAdvantage","attackerCount","defenderFleet","advantage","explanation","effectivenessRatio","calculateTacticalAdvantages","attackerFleet","advantages","push","calculateCasualtyPercentages","event","attackerTotal","defenderTotal","attackerCasualties","attacker","defenderCasualties","defender","attackerLossRate","defenderLossRate","calculateEffectivenessRatios","attackerFrigateEff","attackerCruiserEff","attackerBattleshipEff","attackerEffectiveness","defenderFrigateEff","defenderCruiserEff","defenderBattleshipEff","defenderEffectiveness","determineBattlePhases","phases","strengthRatio","Infinity","openingAdvantage","openingDescription","mainAdvantage","mainDescription","phase","description","attackerHeavy","defenderHeavy","cleanupAdvantage","cleanupDescription","createEnhancedCombatDisplay","tacticalAdvantages","battlePhases","effectivenessRatios","casualtyPercentages","analyzeFleetBalance","balance","recommendation","strengths","weaknesses","frigateRatio","cruiserRatio","battleshipRatio","GameDisplay","config","combatDisplay","showTacticalAnalysis","showBattlePhases","detailedCasualties","useEnhancedFormatting","colorManager","useColors","tacticalAnalyzer","displayGameState","gameState","displayPlayerResources","displayFleetStatus","displayConstructionQueue","displayIntelligence","resources","metalIncome","energyIncome","homeFleet","homeSystem","inTransit","outbound","forEach","movement","index","composition","getFleetMovementStatus","queue","economy","constructionQueue","order","getConstructionProgress","structures","reactors","mines","intel","intelligence","lastScanTurn","knownFleet","knownEnemyFleet","displayDetailedStatus","combatLog","slice","displayHelp","displayTurnResult","turnResult","errors","combatEvents","displayCombatEvent","displayBasicCombatEvent","displayTurnSummary","gameEnded","Error","calculateFleetTotal","displayBasicCombatEventFallback","Array","isArray","eventCount","playerVictories","playerDefeats","validateCombatEvent","isValid","turn","attackerFleetValidation","validateFleetComposition","defenderFleetValidation","attackerCasualtiesValidation","defenderCasualtiesValidation","attackerSurvivorsValidation","defenderSurvivorsValidation","attackerOriginalTotal","attackerCasualtiesTotal","attackerSurvivorsTotal","defenderOriginalTotal","defenderCasualtiesTotal","defenderSurvivorsTotal","context","shipTypes","shipType","count","createFallbackCombatEvent","originalEvent","createSafeFleetComposition","validateShipCount","validation","fallbackEvent","attackerName","defenderName","attackerType","defenderType","enhancedDisplay","displayDetailedFleetComposition","advantageColor","displayBattlePhase","displayBattleExplanation","displayEnhancedCasualties","displayBasicCasualties","displayEnhancedSurvivors","fallbackError","label","phaseNumber","formatPhaseAdvantage","formatStrengthRatio","displayText","ratio","ratioText","toFixed","attackerSeverity","getCasualtySeverity","getCasualtySeverityColor","defenderSeverity","formatCasualtyBreakdown","getCasualtyTacticalContext","displayComparativeLossAnalysis","attackerSurvivors","defenderSurvivors","attackerOriginal","defenderOriginal","survivalRate","getSurvivalRateColor","getSurvivorTacticalContext","assessDefensiveStrength","parts","join","lossRate","originalFleet","totalCasualties","totalOriginal","frigateRate","cruiserRate","battleshipRate","maxRate","attackerRate","defenderRate","abs","role","totalSurvivors","displayGameOver","winner","victoryType","displayError","message","formatNumber","num","toLocaleString","formatIncome","income","padNumber","width","toString","padStart","missionType","arrivalTurn","remaining","turnsRemaining","InputHandler","processCommand","input","trimmed","trim","success","tokens","split","commandType","parseBuildCommand","parseAttackCommand","parseScanCommand","command","type","quantityStr","quantity","parseInt","buildTypeStr","buildType","UNIT_TYPES","STRUCTURE_TYPES","validationResult","validateBuildCommand","attackFleet","validateAttackCommand","target","scanTypeStr","SCAN_TYPES","scanType","validateScanCommand","costs","getBuildCosts","totalMetalCost","metal","totalEnergyCost","energy","upkeepCosts","getUpkeepCosts","totalMetalUpkeep","totalEnergyUpkeep","projectedMetalIncome","projectedEnergyIncome","playerFleet","cost","SCAN_COSTS","reactor","mine","getCommandSuggestions","partialInput","partial","filter","cmd","startsWith","validateSyntax","valid","i","GameController","gameEngine","executeCommand","executeBuildCommand","executeAttackCommand","executeScanCommand","gameStateChanged","executeEndTurn","getGameState","buildOrder","currentCount","createStructureBuildOrder","unitStats","createUnitBuildOrder","pendingPlayerActions","itemName","returnTurn","scanResult","performScan","fleetData","formatScanResult","processTurn","lastTurnResult","getCurrentTurn","aiFleet","ai","totalShips","accuracy","random","reportedTotal","applyAccuracy","factor","economicData","intent","determineAIIntent","strategicIntent","aiIncome","result","getPendingActions","clearPendingActions","getLastTurnResult","getGameEngine","ErrorHandler","handleError","severity","timestamp","Date","recoverable","isRecoverable","maxErrorHistory","shift","canContinue","userMessage","shouldRestart","handleGameStateError","validationErrors","criticalErrors","highErrors","allErrors","handleTurnProcessingError","turnErrors","handleUserInputError","inputError","handleSystemError","isMemoryError","isFileError","isNetworkError","getRecentErrors","getErrorStatistics","byType","runtime","user_input","system","game_logic","bySeverity","low","medium","high","critical","recentCritical","oneHourAgo","now","clearErrorHistory","isSystemHealthy","issues","healthy","getRecoverySuggestions","suggestions","CLIInterface","gameController","gameDisplay","inputHandler","start","isRunning","displayWelcome","isGameOver","processPlayerTurn","stop","turnComplete","gameStateValidation","validateGameState","errorResponse","getPlayerInput","commandResult","processCommandSafely","executionResult","Promise","resolve","write","handleInput","data","stdin","removeListener","on","getGameStatistics","performHealthCheck","systemHealth","displayHealthCheck","health","issue","suggestion","resetGame","shutdown"],"mappings":"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"}